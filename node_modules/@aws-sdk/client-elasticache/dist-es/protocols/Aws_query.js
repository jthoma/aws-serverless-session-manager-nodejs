import { parseXmlBody as parseBody, parseXmlErrorBody as parseErrorBody } from "@aws-sdk/core";
import { HttpRequest as __HttpRequest } from "@smithy/protocol-http";
import { collectBody, decorateServiceException as __decorateServiceException, expectNonNull as __expectNonNull, expectString as __expectString, extendedEncodeURIComponent as __extendedEncodeURIComponent, getArrayIfSingleItem as __getArrayIfSingleItem, parseBoolean as __parseBoolean, parseRfc3339DateTimeWithOffset as __parseRfc3339DateTimeWithOffset, serializeDateTime as __serializeDateTime, strictParseFloat as __strictParseFloat, strictParseInt32 as __strictParseInt32, withBaseException, } from "@smithy/smithy-client";
import { ElastiCacheServiceException as __BaseException } from "../models/ElastiCacheServiceException";
import { AuthorizationAlreadyExistsFault, AuthorizationNotFoundFault, CacheClusterAlreadyExistsFault, CacheClusterNotFoundFault, CacheParameterGroupAlreadyExistsFault, CacheParameterGroupNotFoundFault, CacheParameterGroupQuotaExceededFault, CacheSecurityGroupAlreadyExistsFault, CacheSecurityGroupNotFoundFault, CacheSecurityGroupQuotaExceededFault, CacheSubnetGroupAlreadyExistsFault, CacheSubnetGroupInUse, CacheSubnetGroupNotFoundFault, CacheSubnetGroupQuotaExceededFault, CacheSubnetQuotaExceededFault, ClusterQuotaForCustomerExceededFault, DefaultUserAssociatedToUserGroupFault, DefaultUserRequired, DuplicateUserNameFault, GlobalReplicationGroupAlreadyExistsFault, GlobalReplicationGroupNotFoundFault, InsufficientCacheClusterCapacityFault, InvalidARNFault, InvalidCacheClusterStateFault, InvalidCacheParameterGroupStateFault, InvalidCacheSecurityGroupStateFault, InvalidCredentialsException, InvalidGlobalReplicationGroupStateFault, InvalidKMSKeyFault, InvalidParameterCombinationException, InvalidParameterValueException, InvalidReplicationGroupStateFault, InvalidServerlessCacheSnapshotStateFault, InvalidServerlessCacheStateFault, InvalidSnapshotStateFault, InvalidSubnet, InvalidUserGroupStateFault, InvalidUserStateFault, InvalidVPCNetworkStateFault, NodeGroupsPerReplicationGroupQuotaExceededFault, NodeQuotaForClusterExceededFault, NodeQuotaForCustomerExceededFault, NoOperationFault, ReplicationGroupAlreadyExistsFault, ReplicationGroupNotFoundFault, ReplicationGroupNotUnderMigrationFault, ReservedCacheNodeAlreadyExistsFault, ReservedCacheNodeNotFoundFault, ReservedCacheNodeQuotaExceededFault, ReservedCacheNodesOfferingNotFoundFault, ServerlessCacheAlreadyExistsFault, ServerlessCacheNotFoundFault, ServerlessCacheQuotaForCustomerExceededFault, ServerlessCacheSnapshotAlreadyExistsFault, ServerlessCacheSnapshotNotFoundFault, ServerlessCacheSnapshotQuotaExceededFault, ServiceLinkedRoleNotFoundFault, ServiceUpdateNotFoundFault, SnapshotAlreadyExistsFault, SnapshotFeatureNotSupportedFault, SnapshotNotFoundFault, SnapshotQuotaExceededFault, SubnetInUse, SubnetNotAllowedFault, TagNotFoundFault, TagQuotaPerResourceExceeded, UserAlreadyExistsFault, UserGroupAlreadyExistsFault, UserGroupNotFoundFault, UserGroupQuotaExceededFault, UserNotFoundFault, UserQuotaExceededFault, } from "../models/models_0";
import { APICallRateForCustomerExceededFault, NodeGroupNotFoundFault, ReplicationGroupAlreadyUnderMigrationFault, TestFailoverNotAvailableFault, } from "../models/models_1";
export const se_AddTagsToResourceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AddTagsToResourceMessage(input, context),
        [_A]: _ATTR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AuthorizeCacheSecurityGroupIngressCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AuthorizeCacheSecurityGroupIngressMessage(input, context),
        [_A]: _ACSGI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_BatchApplyUpdateActionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_BatchApplyUpdateActionMessage(input, context),
        [_A]: _BAUA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_BatchStopUpdateActionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_BatchStopUpdateActionMessage(input, context),
        [_A]: _BSUA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CompleteMigrationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CompleteMigrationMessage(input, context),
        [_A]: _CM,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CopyServerlessCacheSnapshotCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CopyServerlessCacheSnapshotRequest(input, context),
        [_A]: _CSCS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CopySnapshotCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CopySnapshotMessage(input, context),
        [_A]: _CS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateCacheClusterCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateCacheClusterMessage(input, context),
        [_A]: _CCC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateCacheParameterGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateCacheParameterGroupMessage(input, context),
        [_A]: _CCPG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateCacheSecurityGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateCacheSecurityGroupMessage(input, context),
        [_A]: _CCSG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateCacheSubnetGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateCacheSubnetGroupMessage(input, context),
        [_A]: _CCSGr,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateGlobalReplicationGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateGlobalReplicationGroupMessage(input, context),
        [_A]: _CGRG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateReplicationGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateReplicationGroupMessage(input, context),
        [_A]: _CRG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateServerlessCacheCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateServerlessCacheRequest(input, context),
        [_A]: _CSC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateServerlessCacheSnapshotCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateServerlessCacheSnapshotRequest(input, context),
        [_A]: _CSCSr,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateSnapshotCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateSnapshotMessage(input, context),
        [_A]: _CSr,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateUserCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateUserMessage(input, context),
        [_A]: _CU,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateUserGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateUserGroupMessage(input, context),
        [_A]: _CUG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DecreaseNodeGroupsInGlobalReplicationGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DecreaseNodeGroupsInGlobalReplicationGroupMessage(input, context),
        [_A]: _DNGIGRG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DecreaseReplicaCountCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DecreaseReplicaCountMessage(input, context),
        [_A]: _DRC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteCacheClusterCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteCacheClusterMessage(input, context),
        [_A]: _DCC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteCacheParameterGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteCacheParameterGroupMessage(input, context),
        [_A]: _DCPG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteCacheSecurityGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteCacheSecurityGroupMessage(input, context),
        [_A]: _DCSG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteCacheSubnetGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteCacheSubnetGroupMessage(input, context),
        [_A]: _DCSGe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteGlobalReplicationGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteGlobalReplicationGroupMessage(input, context),
        [_A]: _DGRG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteReplicationGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteReplicationGroupMessage(input, context),
        [_A]: _DRG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteServerlessCacheCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteServerlessCacheRequest(input, context),
        [_A]: _DSC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteServerlessCacheSnapshotCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteServerlessCacheSnapshotRequest(input, context),
        [_A]: _DSCS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteSnapshotCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteSnapshotMessage(input, context),
        [_A]: _DS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteUserCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteUserMessage(input, context),
        [_A]: _DU,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteUserGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteUserGroupMessage(input, context),
        [_A]: _DUG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeCacheClustersCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeCacheClustersMessage(input, context),
        [_A]: _DCCe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeCacheEngineVersionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeCacheEngineVersionsMessage(input, context),
        [_A]: _DCEV,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeCacheParameterGroupsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeCacheParameterGroupsMessage(input, context),
        [_A]: _DCPGe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeCacheParametersCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeCacheParametersMessage(input, context),
        [_A]: _DCP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeCacheSecurityGroupsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeCacheSecurityGroupsMessage(input, context),
        [_A]: _DCSGes,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeCacheSubnetGroupsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeCacheSubnetGroupsMessage(input, context),
        [_A]: _DCSGesc,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeEngineDefaultParametersCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeEngineDefaultParametersMessage(input, context),
        [_A]: _DEDP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeEventsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeEventsMessage(input, context),
        [_A]: _DE,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeGlobalReplicationGroupsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeGlobalReplicationGroupsMessage(input, context),
        [_A]: _DGRGe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeReplicationGroupsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeReplicationGroupsMessage(input, context),
        [_A]: _DRGe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeReservedCacheNodesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeReservedCacheNodesMessage(input, context),
        [_A]: _DRCN,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeReservedCacheNodesOfferingsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeReservedCacheNodesOfferingsMessage(input, context),
        [_A]: _DRCNO,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeServerlessCachesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeServerlessCachesRequest(input, context),
        [_A]: _DSCe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeServerlessCacheSnapshotsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeServerlessCacheSnapshotsRequest(input, context),
        [_A]: _DSCSe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeServiceUpdatesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeServiceUpdatesMessage(input, context),
        [_A]: _DSU,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeSnapshotsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeSnapshotsMessage(input, context),
        [_A]: _DSe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeUpdateActionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeUpdateActionsMessage(input, context),
        [_A]: _DUA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeUserGroupsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeUserGroupsMessage(input, context),
        [_A]: _DUGe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeUsersCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeUsersMessage(input, context),
        [_A]: _DUe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DisassociateGlobalReplicationGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DisassociateGlobalReplicationGroupMessage(input, context),
        [_A]: _DGRGi,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ExportServerlessCacheSnapshotCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ExportServerlessCacheSnapshotRequest(input, context),
        [_A]: _ESCS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_FailoverGlobalReplicationGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_FailoverGlobalReplicationGroupMessage(input, context),
        [_A]: _FGRG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_IncreaseNodeGroupsInGlobalReplicationGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_IncreaseNodeGroupsInGlobalReplicationGroupMessage(input, context),
        [_A]: _INGIGRG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_IncreaseReplicaCountCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_IncreaseReplicaCountMessage(input, context),
        [_A]: _IRC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListAllowedNodeTypeModificationsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListAllowedNodeTypeModificationsMessage(input, context),
        [_A]: _LANTM,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListTagsForResourceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListTagsForResourceMessage(input, context),
        [_A]: _LTFR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyCacheClusterCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyCacheClusterMessage(input, context),
        [_A]: _MCC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyCacheParameterGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyCacheParameterGroupMessage(input, context),
        [_A]: _MCPG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyCacheSubnetGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyCacheSubnetGroupMessage(input, context),
        [_A]: _MCSG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyGlobalReplicationGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyGlobalReplicationGroupMessage(input, context),
        [_A]: _MGRG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyReplicationGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyReplicationGroupMessage(input, context),
        [_A]: _MRG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyReplicationGroupShardConfigurationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyReplicationGroupShardConfigurationMessage(input, context),
        [_A]: _MRGSC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyServerlessCacheCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyServerlessCacheRequest(input, context),
        [_A]: _MSC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyUserCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyUserMessage(input, context),
        [_A]: _MU,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyUserGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyUserGroupMessage(input, context),
        [_A]: _MUG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_PurchaseReservedCacheNodesOfferingCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PurchaseReservedCacheNodesOfferingMessage(input, context),
        [_A]: _PRCNO,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RebalanceSlotsInGlobalReplicationGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RebalanceSlotsInGlobalReplicationGroupMessage(input, context),
        [_A]: _RSIGRG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RebootCacheClusterCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RebootCacheClusterMessage(input, context),
        [_A]: _RCC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RemoveTagsFromResourceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RemoveTagsFromResourceMessage(input, context),
        [_A]: _RTFR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ResetCacheParameterGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ResetCacheParameterGroupMessage(input, context),
        [_A]: _RCPG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RevokeCacheSecurityGroupIngressCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RevokeCacheSecurityGroupIngressMessage(input, context),
        [_A]: _RCSGI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_StartMigrationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_StartMigrationMessage(input, context),
        [_A]: _SM,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_TestFailoverCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_TestFailoverMessage(input, context),
        [_A]: _TF,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_TestMigrationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_TestMigrationMessage(input, context),
        [_A]: _TM,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const de_AddTagsToResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_TagListMessage(data.AddTagsToResourceResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AuthorizeCacheSecurityGroupIngressCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AuthorizeCacheSecurityGroupIngressResult(data.AuthorizeCacheSecurityGroupIngressResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_BatchApplyUpdateActionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateActionResultsMessage(data.BatchApplyUpdateActionResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_BatchStopUpdateActionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateActionResultsMessage(data.BatchStopUpdateActionResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CompleteMigrationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CompleteMigrationResponse(data.CompleteMigrationResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CopyServerlessCacheSnapshotCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CopyServerlessCacheSnapshotResponse(data.CopyServerlessCacheSnapshotResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CopySnapshotCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CopySnapshotResult(data.CopySnapshotResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateCacheClusterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateCacheClusterResult(data.CreateCacheClusterResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateCacheParameterGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateCacheParameterGroupResult(data.CreateCacheParameterGroupResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateCacheSecurityGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateCacheSecurityGroupResult(data.CreateCacheSecurityGroupResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateCacheSubnetGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateCacheSubnetGroupResult(data.CreateCacheSubnetGroupResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateGlobalReplicationGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateGlobalReplicationGroupResult(data.CreateGlobalReplicationGroupResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateReplicationGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateReplicationGroupResult(data.CreateReplicationGroupResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateServerlessCacheCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateServerlessCacheResponse(data.CreateServerlessCacheResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateServerlessCacheSnapshotCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateServerlessCacheSnapshotResponse(data.CreateServerlessCacheSnapshotResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateSnapshotCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateSnapshotResult(data.CreateSnapshotResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateUserCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_User(data.CreateUserResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateUserGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UserGroup(data.CreateUserGroupResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DecreaseNodeGroupsInGlobalReplicationGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DecreaseNodeGroupsInGlobalReplicationGroupResult(data.DecreaseNodeGroupsInGlobalReplicationGroupResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DecreaseReplicaCountCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DecreaseReplicaCountResult(data.DecreaseReplicaCountResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteCacheClusterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteCacheClusterResult(data.DeleteCacheClusterResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteCacheParameterGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DeleteCacheSecurityGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DeleteCacheSubnetGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DeleteGlobalReplicationGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteGlobalReplicationGroupResult(data.DeleteGlobalReplicationGroupResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteReplicationGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteReplicationGroupResult(data.DeleteReplicationGroupResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteServerlessCacheCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteServerlessCacheResponse(data.DeleteServerlessCacheResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteServerlessCacheSnapshotCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteServerlessCacheSnapshotResponse(data.DeleteServerlessCacheSnapshotResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteSnapshotCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteSnapshotResult(data.DeleteSnapshotResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteUserCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_User(data.DeleteUserResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteUserGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UserGroup(data.DeleteUserGroupResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeCacheClustersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CacheClusterMessage(data.DescribeCacheClustersResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeCacheEngineVersionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CacheEngineVersionMessage(data.DescribeCacheEngineVersionsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeCacheParameterGroupsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CacheParameterGroupsMessage(data.DescribeCacheParameterGroupsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeCacheParametersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CacheParameterGroupDetails(data.DescribeCacheParametersResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeCacheSecurityGroupsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CacheSecurityGroupMessage(data.DescribeCacheSecurityGroupsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeCacheSubnetGroupsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CacheSubnetGroupMessage(data.DescribeCacheSubnetGroupsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeEngineDefaultParametersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeEngineDefaultParametersResult(data.DescribeEngineDefaultParametersResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeEventsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_EventsMessage(data.DescribeEventsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeGlobalReplicationGroupsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeGlobalReplicationGroupsResult(data.DescribeGlobalReplicationGroupsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeReplicationGroupsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ReplicationGroupMessage(data.DescribeReplicationGroupsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeReservedCacheNodesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ReservedCacheNodeMessage(data.DescribeReservedCacheNodesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeReservedCacheNodesOfferingsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ReservedCacheNodesOfferingMessage(data.DescribeReservedCacheNodesOfferingsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeServerlessCachesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeServerlessCachesResponse(data.DescribeServerlessCachesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeServerlessCacheSnapshotsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeServerlessCacheSnapshotsResponse(data.DescribeServerlessCacheSnapshotsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeServiceUpdatesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ServiceUpdatesMessage(data.DescribeServiceUpdatesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeSnapshotsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeSnapshotsListMessage(data.DescribeSnapshotsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeUpdateActionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateActionsMessage(data.DescribeUpdateActionsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeUserGroupsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeUserGroupsResult(data.DescribeUserGroupsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeUsersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeUsersResult(data.DescribeUsersResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DisassociateGlobalReplicationGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DisassociateGlobalReplicationGroupResult(data.DisassociateGlobalReplicationGroupResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ExportServerlessCacheSnapshotCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ExportServerlessCacheSnapshotResponse(data.ExportServerlessCacheSnapshotResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_FailoverGlobalReplicationGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_FailoverGlobalReplicationGroupResult(data.FailoverGlobalReplicationGroupResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_IncreaseNodeGroupsInGlobalReplicationGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_IncreaseNodeGroupsInGlobalReplicationGroupResult(data.IncreaseNodeGroupsInGlobalReplicationGroupResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_IncreaseReplicaCountCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_IncreaseReplicaCountResult(data.IncreaseReplicaCountResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ListAllowedNodeTypeModificationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AllowedNodeTypeModificationsMessage(data.ListAllowedNodeTypeModificationsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_TagListMessage(data.ListTagsForResourceResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyCacheClusterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyCacheClusterResult(data.ModifyCacheClusterResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyCacheParameterGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CacheParameterGroupNameMessage(data.ModifyCacheParameterGroupResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyCacheSubnetGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyCacheSubnetGroupResult(data.ModifyCacheSubnetGroupResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyGlobalReplicationGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyGlobalReplicationGroupResult(data.ModifyGlobalReplicationGroupResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyReplicationGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyReplicationGroupResult(data.ModifyReplicationGroupResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyReplicationGroupShardConfigurationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyReplicationGroupShardConfigurationResult(data.ModifyReplicationGroupShardConfigurationResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyServerlessCacheCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyServerlessCacheResponse(data.ModifyServerlessCacheResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyUserCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_User(data.ModifyUserResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyUserGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UserGroup(data.ModifyUserGroupResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_PurchaseReservedCacheNodesOfferingCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_PurchaseReservedCacheNodesOfferingResult(data.PurchaseReservedCacheNodesOfferingResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_RebalanceSlotsInGlobalReplicationGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RebalanceSlotsInGlobalReplicationGroupResult(data.RebalanceSlotsInGlobalReplicationGroupResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_RebootCacheClusterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RebootCacheClusterResult(data.RebootCacheClusterResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_RemoveTagsFromResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_TagListMessage(data.RemoveTagsFromResourceResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ResetCacheParameterGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CacheParameterGroupNameMessage(data.ResetCacheParameterGroupResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_RevokeCacheSecurityGroupIngressCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RevokeCacheSecurityGroupIngressResult(data.RevokeCacheSecurityGroupIngressResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_StartMigrationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_StartMigrationResponse(data.StartMigrationResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_TestFailoverCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_TestFailoverResult(data.TestFailoverResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_TestMigrationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_TestMigrationResponse(data.TestMigrationResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CacheClusterNotFound":
        case "com.amazonaws.elasticache#CacheClusterNotFoundFault":
            throw await de_CacheClusterNotFoundFaultRes(parsedOutput, context);
        case "CacheParameterGroupNotFound":
        case "com.amazonaws.elasticache#CacheParameterGroupNotFoundFault":
            throw await de_CacheParameterGroupNotFoundFaultRes(parsedOutput, context);
        case "CacheSecurityGroupNotFound":
        case "com.amazonaws.elasticache#CacheSecurityGroupNotFoundFault":
            throw await de_CacheSecurityGroupNotFoundFaultRes(parsedOutput, context);
        case "CacheSubnetGroupNotFoundFault":
        case "com.amazonaws.elasticache#CacheSubnetGroupNotFoundFault":
            throw await de_CacheSubnetGroupNotFoundFaultRes(parsedOutput, context);
        case "InvalidARN":
        case "com.amazonaws.elasticache#InvalidARNFault":
            throw await de_InvalidARNFaultRes(parsedOutput, context);
        case "InvalidReplicationGroupState":
        case "com.amazonaws.elasticache#InvalidReplicationGroupStateFault":
            throw await de_InvalidReplicationGroupStateFaultRes(parsedOutput, context);
        case "InvalidServerlessCacheSnapshotStateFault":
        case "com.amazonaws.elasticache#InvalidServerlessCacheSnapshotStateFault":
            throw await de_InvalidServerlessCacheSnapshotStateFaultRes(parsedOutput, context);
        case "InvalidServerlessCacheStateFault":
        case "com.amazonaws.elasticache#InvalidServerlessCacheStateFault":
            throw await de_InvalidServerlessCacheStateFaultRes(parsedOutput, context);
        case "ReplicationGroupNotFoundFault":
        case "com.amazonaws.elasticache#ReplicationGroupNotFoundFault":
            throw await de_ReplicationGroupNotFoundFaultRes(parsedOutput, context);
        case "ReservedCacheNodeNotFound":
        case "com.amazonaws.elasticache#ReservedCacheNodeNotFoundFault":
            throw await de_ReservedCacheNodeNotFoundFaultRes(parsedOutput, context);
        case "ServerlessCacheNotFoundFault":
        case "com.amazonaws.elasticache#ServerlessCacheNotFoundFault":
            throw await de_ServerlessCacheNotFoundFaultRes(parsedOutput, context);
        case "ServerlessCacheSnapshotNotFoundFault":
        case "com.amazonaws.elasticache#ServerlessCacheSnapshotNotFoundFault":
            throw await de_ServerlessCacheSnapshotNotFoundFaultRes(parsedOutput, context);
        case "SnapshotNotFoundFault":
        case "com.amazonaws.elasticache#SnapshotNotFoundFault":
            throw await de_SnapshotNotFoundFaultRes(parsedOutput, context);
        case "TagQuotaPerResourceExceeded":
        case "com.amazonaws.elasticache#TagQuotaPerResourceExceeded":
            throw await de_TagQuotaPerResourceExceededRes(parsedOutput, context);
        case "UserGroupNotFound":
        case "com.amazonaws.elasticache#UserGroupNotFoundFault":
            throw await de_UserGroupNotFoundFaultRes(parsedOutput, context);
        case "UserNotFound":
        case "com.amazonaws.elasticache#UserNotFoundFault":
            throw await de_UserNotFoundFaultRes(parsedOutput, context);
        case "AuthorizationAlreadyExists":
        case "com.amazonaws.elasticache#AuthorizationAlreadyExistsFault":
            throw await de_AuthorizationAlreadyExistsFaultRes(parsedOutput, context);
        case "InvalidCacheSecurityGroupState":
        case "com.amazonaws.elasticache#InvalidCacheSecurityGroupStateFault":
            throw await de_InvalidCacheSecurityGroupStateFaultRes(parsedOutput, context);
        case "InvalidParameterCombination":
        case "com.amazonaws.elasticache#InvalidParameterCombinationException":
            throw await de_InvalidParameterCombinationExceptionRes(parsedOutput, context);
        case "InvalidParameterValue":
        case "com.amazonaws.elasticache#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        case "ServiceUpdateNotFoundFault":
        case "com.amazonaws.elasticache#ServiceUpdateNotFoundFault":
            throw await de_ServiceUpdateNotFoundFaultRes(parsedOutput, context);
        case "ReplicationGroupNotUnderMigrationFault":
        case "com.amazonaws.elasticache#ReplicationGroupNotUnderMigrationFault":
            throw await de_ReplicationGroupNotUnderMigrationFaultRes(parsedOutput, context);
        case "ServerlessCacheSnapshotAlreadyExistsFault":
        case "com.amazonaws.elasticache#ServerlessCacheSnapshotAlreadyExistsFault":
            throw await de_ServerlessCacheSnapshotAlreadyExistsFaultRes(parsedOutput, context);
        case "ServerlessCacheSnapshotQuotaExceededFault":
        case "com.amazonaws.elasticache#ServerlessCacheSnapshotQuotaExceededFault":
            throw await de_ServerlessCacheSnapshotQuotaExceededFaultRes(parsedOutput, context);
        case "ServiceLinkedRoleNotFoundFault":
        case "com.amazonaws.elasticache#ServiceLinkedRoleNotFoundFault":
            throw await de_ServiceLinkedRoleNotFoundFaultRes(parsedOutput, context);
        case "InvalidSnapshotState":
        case "com.amazonaws.elasticache#InvalidSnapshotStateFault":
            throw await de_InvalidSnapshotStateFaultRes(parsedOutput, context);
        case "SnapshotAlreadyExistsFault":
        case "com.amazonaws.elasticache#SnapshotAlreadyExistsFault":
            throw await de_SnapshotAlreadyExistsFaultRes(parsedOutput, context);
        case "SnapshotQuotaExceededFault":
        case "com.amazonaws.elasticache#SnapshotQuotaExceededFault":
            throw await de_SnapshotQuotaExceededFaultRes(parsedOutput, context);
        case "CacheClusterAlreadyExists":
        case "com.amazonaws.elasticache#CacheClusterAlreadyExistsFault":
            throw await de_CacheClusterAlreadyExistsFaultRes(parsedOutput, context);
        case "ClusterQuotaForCustomerExceeded":
        case "com.amazonaws.elasticache#ClusterQuotaForCustomerExceededFault":
            throw await de_ClusterQuotaForCustomerExceededFaultRes(parsedOutput, context);
        case "InsufficientCacheClusterCapacity":
        case "com.amazonaws.elasticache#InsufficientCacheClusterCapacityFault":
            throw await de_InsufficientCacheClusterCapacityFaultRes(parsedOutput, context);
        case "InvalidVPCNetworkStateFault":
        case "com.amazonaws.elasticache#InvalidVPCNetworkStateFault":
            throw await de_InvalidVPCNetworkStateFaultRes(parsedOutput, context);
        case "NodeQuotaForClusterExceeded":
        case "com.amazonaws.elasticache#NodeQuotaForClusterExceededFault":
            throw await de_NodeQuotaForClusterExceededFaultRes(parsedOutput, context);
        case "NodeQuotaForCustomerExceeded":
        case "com.amazonaws.elasticache#NodeQuotaForCustomerExceededFault":
            throw await de_NodeQuotaForCustomerExceededFaultRes(parsedOutput, context);
        case "CacheParameterGroupAlreadyExists":
        case "com.amazonaws.elasticache#CacheParameterGroupAlreadyExistsFault":
            throw await de_CacheParameterGroupAlreadyExistsFaultRes(parsedOutput, context);
        case "CacheParameterGroupQuotaExceeded":
        case "com.amazonaws.elasticache#CacheParameterGroupQuotaExceededFault":
            throw await de_CacheParameterGroupQuotaExceededFaultRes(parsedOutput, context);
        case "InvalidCacheParameterGroupState":
        case "com.amazonaws.elasticache#InvalidCacheParameterGroupStateFault":
            throw await de_InvalidCacheParameterGroupStateFaultRes(parsedOutput, context);
        case "CacheSecurityGroupAlreadyExists":
        case "com.amazonaws.elasticache#CacheSecurityGroupAlreadyExistsFault":
            throw await de_CacheSecurityGroupAlreadyExistsFaultRes(parsedOutput, context);
        case "QuotaExceeded.CacheSecurityGroup":
        case "com.amazonaws.elasticache#CacheSecurityGroupQuotaExceededFault":
            throw await de_CacheSecurityGroupQuotaExceededFaultRes(parsedOutput, context);
        case "CacheSubnetGroupAlreadyExists":
        case "com.amazonaws.elasticache#CacheSubnetGroupAlreadyExistsFault":
            throw await de_CacheSubnetGroupAlreadyExistsFaultRes(parsedOutput, context);
        case "CacheSubnetGroupQuotaExceeded":
        case "com.amazonaws.elasticache#CacheSubnetGroupQuotaExceededFault":
            throw await de_CacheSubnetGroupQuotaExceededFaultRes(parsedOutput, context);
        case "CacheSubnetQuotaExceededFault":
        case "com.amazonaws.elasticache#CacheSubnetQuotaExceededFault":
            throw await de_CacheSubnetQuotaExceededFaultRes(parsedOutput, context);
        case "InvalidSubnet":
        case "com.amazonaws.elasticache#InvalidSubnet":
            throw await de_InvalidSubnetRes(parsedOutput, context);
        case "SubnetNotAllowedFault":
        case "com.amazonaws.elasticache#SubnetNotAllowedFault":
            throw await de_SubnetNotAllowedFaultRes(parsedOutput, context);
        case "GlobalReplicationGroupAlreadyExistsFault":
        case "com.amazonaws.elasticache#GlobalReplicationGroupAlreadyExistsFault":
            throw await de_GlobalReplicationGroupAlreadyExistsFaultRes(parsedOutput, context);
        case "GlobalReplicationGroupNotFoundFault":
        case "com.amazonaws.elasticache#GlobalReplicationGroupNotFoundFault":
            throw await de_GlobalReplicationGroupNotFoundFaultRes(parsedOutput, context);
        case "InvalidCacheClusterState":
        case "com.amazonaws.elasticache#InvalidCacheClusterStateFault":
            throw await de_InvalidCacheClusterStateFaultRes(parsedOutput, context);
        case "InvalidGlobalReplicationGroupState":
        case "com.amazonaws.elasticache#InvalidGlobalReplicationGroupStateFault":
            throw await de_InvalidGlobalReplicationGroupStateFaultRes(parsedOutput, context);
        case "InvalidUserGroupState":
        case "com.amazonaws.elasticache#InvalidUserGroupStateFault":
            throw await de_InvalidUserGroupStateFaultRes(parsedOutput, context);
        case "NodeGroupsPerReplicationGroupQuotaExceeded":
        case "com.amazonaws.elasticache#NodeGroupsPerReplicationGroupQuotaExceededFault":
            throw await de_NodeGroupsPerReplicationGroupQuotaExceededFaultRes(parsedOutput, context);
        case "ReplicationGroupAlreadyExists":
        case "com.amazonaws.elasticache#ReplicationGroupAlreadyExistsFault":
            throw await de_ReplicationGroupAlreadyExistsFaultRes(parsedOutput, context);
        case "InvalidCredentialsException":
        case "com.amazonaws.elasticache#InvalidCredentialsException":
            throw await de_InvalidCredentialsExceptionRes(parsedOutput, context);
        case "ServerlessCacheAlreadyExistsFault":
        case "com.amazonaws.elasticache#ServerlessCacheAlreadyExistsFault":
            throw await de_ServerlessCacheAlreadyExistsFaultRes(parsedOutput, context);
        case "ServerlessCacheQuotaForCustomerExceededFault":
        case "com.amazonaws.elasticache#ServerlessCacheQuotaForCustomerExceededFault":
            throw await de_ServerlessCacheQuotaForCustomerExceededFaultRes(parsedOutput, context);
        case "SnapshotFeatureNotSupportedFault":
        case "com.amazonaws.elasticache#SnapshotFeatureNotSupportedFault":
            throw await de_SnapshotFeatureNotSupportedFaultRes(parsedOutput, context);
        case "DuplicateUserName":
        case "com.amazonaws.elasticache#DuplicateUserNameFault":
            throw await de_DuplicateUserNameFaultRes(parsedOutput, context);
        case "UserAlreadyExists":
        case "com.amazonaws.elasticache#UserAlreadyExistsFault":
            throw await de_UserAlreadyExistsFaultRes(parsedOutput, context);
        case "UserQuotaExceeded":
        case "com.amazonaws.elasticache#UserQuotaExceededFault":
            throw await de_UserQuotaExceededFaultRes(parsedOutput, context);
        case "DefaultUserRequired":
        case "com.amazonaws.elasticache#DefaultUserRequired":
            throw await de_DefaultUserRequiredRes(parsedOutput, context);
        case "UserGroupAlreadyExists":
        case "com.amazonaws.elasticache#UserGroupAlreadyExistsFault":
            throw await de_UserGroupAlreadyExistsFaultRes(parsedOutput, context);
        case "UserGroupQuotaExceeded":
        case "com.amazonaws.elasticache#UserGroupQuotaExceededFault":
            throw await de_UserGroupQuotaExceededFaultRes(parsedOutput, context);
        case "NoOperationFault":
        case "com.amazonaws.elasticache#NoOperationFault":
            throw await de_NoOperationFaultRes(parsedOutput, context);
        case "CacheSubnetGroupInUse":
        case "com.amazonaws.elasticache#CacheSubnetGroupInUse":
            throw await de_CacheSubnetGroupInUseRes(parsedOutput, context);
        case "DefaultUserAssociatedToUserGroup":
        case "com.amazonaws.elasticache#DefaultUserAssociatedToUserGroupFault":
            throw await de_DefaultUserAssociatedToUserGroupFaultRes(parsedOutput, context);
        case "InvalidUserState":
        case "com.amazonaws.elasticache#InvalidUserStateFault":
            throw await de_InvalidUserStateFaultRes(parsedOutput, context);
        case "ReservedCacheNodesOfferingNotFound":
        case "com.amazonaws.elasticache#ReservedCacheNodesOfferingNotFoundFault":
            throw await de_ReservedCacheNodesOfferingNotFoundFaultRes(parsedOutput, context);
        case "InvalidKMSKeyFault":
        case "com.amazonaws.elasticache#InvalidKMSKeyFault":
            throw await de_InvalidKMSKeyFaultRes(parsedOutput, context);
        case "SubnetInUse":
        case "com.amazonaws.elasticache#SubnetInUse":
            throw await de_SubnetInUseRes(parsedOutput, context);
        case "ReservedCacheNodeAlreadyExists":
        case "com.amazonaws.elasticache#ReservedCacheNodeAlreadyExistsFault":
            throw await de_ReservedCacheNodeAlreadyExistsFaultRes(parsedOutput, context);
        case "ReservedCacheNodeQuotaExceeded":
        case "com.amazonaws.elasticache#ReservedCacheNodeQuotaExceededFault":
            throw await de_ReservedCacheNodeQuotaExceededFaultRes(parsedOutput, context);
        case "TagNotFound":
        case "com.amazonaws.elasticache#TagNotFoundFault":
            throw await de_TagNotFoundFaultRes(parsedOutput, context);
        case "AuthorizationNotFound":
        case "com.amazonaws.elasticache#AuthorizationNotFoundFault":
            throw await de_AuthorizationNotFoundFaultRes(parsedOutput, context);
        case "ReplicationGroupAlreadyUnderMigrationFault":
        case "com.amazonaws.elasticache#ReplicationGroupAlreadyUnderMigrationFault":
            throw await de_ReplicationGroupAlreadyUnderMigrationFaultRes(parsedOutput, context);
        case "APICallRateForCustomerExceeded":
        case "com.amazonaws.elasticache#APICallRateForCustomerExceededFault":
            throw await de_APICallRateForCustomerExceededFaultRes(parsedOutput, context);
        case "NodeGroupNotFoundFault":
        case "com.amazonaws.elasticache#NodeGroupNotFoundFault":
            throw await de_NodeGroupNotFoundFaultRes(parsedOutput, context);
        case "TestFailoverNotAvailableFault":
        case "com.amazonaws.elasticache#TestFailoverNotAvailableFault":
            throw await de_TestFailoverNotAvailableFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_APICallRateForCustomerExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_APICallRateForCustomerExceededFault(body.Error, context);
    const exception = new APICallRateForCustomerExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_AuthorizationAlreadyExistsFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_AuthorizationAlreadyExistsFault(body.Error, context);
    const exception = new AuthorizationAlreadyExistsFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_AuthorizationNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_AuthorizationNotFoundFault(body.Error, context);
    const exception = new AuthorizationNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_CacheClusterAlreadyExistsFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_CacheClusterAlreadyExistsFault(body.Error, context);
    const exception = new CacheClusterAlreadyExistsFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_CacheClusterNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_CacheClusterNotFoundFault(body.Error, context);
    const exception = new CacheClusterNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_CacheParameterGroupAlreadyExistsFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_CacheParameterGroupAlreadyExistsFault(body.Error, context);
    const exception = new CacheParameterGroupAlreadyExistsFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_CacheParameterGroupNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_CacheParameterGroupNotFoundFault(body.Error, context);
    const exception = new CacheParameterGroupNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_CacheParameterGroupQuotaExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_CacheParameterGroupQuotaExceededFault(body.Error, context);
    const exception = new CacheParameterGroupQuotaExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_CacheSecurityGroupAlreadyExistsFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_CacheSecurityGroupAlreadyExistsFault(body.Error, context);
    const exception = new CacheSecurityGroupAlreadyExistsFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_CacheSecurityGroupNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_CacheSecurityGroupNotFoundFault(body.Error, context);
    const exception = new CacheSecurityGroupNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_CacheSecurityGroupQuotaExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_CacheSecurityGroupQuotaExceededFault(body.Error, context);
    const exception = new CacheSecurityGroupQuotaExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_CacheSubnetGroupAlreadyExistsFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_CacheSubnetGroupAlreadyExistsFault(body.Error, context);
    const exception = new CacheSubnetGroupAlreadyExistsFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_CacheSubnetGroupInUseRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_CacheSubnetGroupInUse(body.Error, context);
    const exception = new CacheSubnetGroupInUse({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_CacheSubnetGroupNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_CacheSubnetGroupNotFoundFault(body.Error, context);
    const exception = new CacheSubnetGroupNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_CacheSubnetGroupQuotaExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_CacheSubnetGroupQuotaExceededFault(body.Error, context);
    const exception = new CacheSubnetGroupQuotaExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_CacheSubnetQuotaExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_CacheSubnetQuotaExceededFault(body.Error, context);
    const exception = new CacheSubnetQuotaExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ClusterQuotaForCustomerExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ClusterQuotaForCustomerExceededFault(body.Error, context);
    const exception = new ClusterQuotaForCustomerExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DefaultUserAssociatedToUserGroupFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DefaultUserAssociatedToUserGroupFault(body.Error, context);
    const exception = new DefaultUserAssociatedToUserGroupFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DefaultUserRequiredRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DefaultUserRequired(body.Error, context);
    const exception = new DefaultUserRequired({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DuplicateUserNameFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DuplicateUserNameFault(body.Error, context);
    const exception = new DuplicateUserNameFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_GlobalReplicationGroupAlreadyExistsFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_GlobalReplicationGroupAlreadyExistsFault(body.Error, context);
    const exception = new GlobalReplicationGroupAlreadyExistsFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_GlobalReplicationGroupNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_GlobalReplicationGroupNotFoundFault(body.Error, context);
    const exception = new GlobalReplicationGroupNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InsufficientCacheClusterCapacityFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InsufficientCacheClusterCapacityFault(body.Error, context);
    const exception = new InsufficientCacheClusterCapacityFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidARNFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidARNFault(body.Error, context);
    const exception = new InvalidARNFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidCacheClusterStateFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidCacheClusterStateFault(body.Error, context);
    const exception = new InvalidCacheClusterStateFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidCacheParameterGroupStateFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidCacheParameterGroupStateFault(body.Error, context);
    const exception = new InvalidCacheParameterGroupStateFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidCacheSecurityGroupStateFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidCacheSecurityGroupStateFault(body.Error, context);
    const exception = new InvalidCacheSecurityGroupStateFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidCredentialsExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidCredentialsException(body.Error, context);
    const exception = new InvalidCredentialsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidGlobalReplicationGroupStateFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidGlobalReplicationGroupStateFault(body.Error, context);
    const exception = new InvalidGlobalReplicationGroupStateFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidKMSKeyFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidKMSKeyFault(body.Error, context);
    const exception = new InvalidKMSKeyFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidParameterCombinationExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidParameterCombinationException(body.Error, context);
    const exception = new InvalidParameterCombinationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidParameterValueExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidParameterValueException(body.Error, context);
    const exception = new InvalidParameterValueException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidReplicationGroupStateFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidReplicationGroupStateFault(body.Error, context);
    const exception = new InvalidReplicationGroupStateFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidServerlessCacheSnapshotStateFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidServerlessCacheSnapshotStateFault(body.Error, context);
    const exception = new InvalidServerlessCacheSnapshotStateFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidServerlessCacheStateFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidServerlessCacheStateFault(body.Error, context);
    const exception = new InvalidServerlessCacheStateFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidSnapshotStateFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidSnapshotStateFault(body.Error, context);
    const exception = new InvalidSnapshotStateFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidSubnetRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidSubnet(body.Error, context);
    const exception = new InvalidSubnet({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidUserGroupStateFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidUserGroupStateFault(body.Error, context);
    const exception = new InvalidUserGroupStateFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidUserStateFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidUserStateFault(body.Error, context);
    const exception = new InvalidUserStateFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidVPCNetworkStateFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidVPCNetworkStateFault(body.Error, context);
    const exception = new InvalidVPCNetworkStateFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_NodeGroupNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_NodeGroupNotFoundFault(body.Error, context);
    const exception = new NodeGroupNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_NodeGroupsPerReplicationGroupQuotaExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_NodeGroupsPerReplicationGroupQuotaExceededFault(body.Error, context);
    const exception = new NodeGroupsPerReplicationGroupQuotaExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_NodeQuotaForClusterExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_NodeQuotaForClusterExceededFault(body.Error, context);
    const exception = new NodeQuotaForClusterExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_NodeQuotaForCustomerExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_NodeQuotaForCustomerExceededFault(body.Error, context);
    const exception = new NodeQuotaForCustomerExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_NoOperationFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_NoOperationFault(body.Error, context);
    const exception = new NoOperationFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ReplicationGroupAlreadyExistsFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ReplicationGroupAlreadyExistsFault(body.Error, context);
    const exception = new ReplicationGroupAlreadyExistsFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ReplicationGroupAlreadyUnderMigrationFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ReplicationGroupAlreadyUnderMigrationFault(body.Error, context);
    const exception = new ReplicationGroupAlreadyUnderMigrationFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ReplicationGroupNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ReplicationGroupNotFoundFault(body.Error, context);
    const exception = new ReplicationGroupNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ReplicationGroupNotUnderMigrationFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ReplicationGroupNotUnderMigrationFault(body.Error, context);
    const exception = new ReplicationGroupNotUnderMigrationFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ReservedCacheNodeAlreadyExistsFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ReservedCacheNodeAlreadyExistsFault(body.Error, context);
    const exception = new ReservedCacheNodeAlreadyExistsFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ReservedCacheNodeNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ReservedCacheNodeNotFoundFault(body.Error, context);
    const exception = new ReservedCacheNodeNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ReservedCacheNodeQuotaExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ReservedCacheNodeQuotaExceededFault(body.Error, context);
    const exception = new ReservedCacheNodeQuotaExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ReservedCacheNodesOfferingNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ReservedCacheNodesOfferingNotFoundFault(body.Error, context);
    const exception = new ReservedCacheNodesOfferingNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ServerlessCacheAlreadyExistsFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ServerlessCacheAlreadyExistsFault(body.Error, context);
    const exception = new ServerlessCacheAlreadyExistsFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ServerlessCacheNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ServerlessCacheNotFoundFault(body.Error, context);
    const exception = new ServerlessCacheNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ServerlessCacheQuotaForCustomerExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ServerlessCacheQuotaForCustomerExceededFault(body.Error, context);
    const exception = new ServerlessCacheQuotaForCustomerExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ServerlessCacheSnapshotAlreadyExistsFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ServerlessCacheSnapshotAlreadyExistsFault(body.Error, context);
    const exception = new ServerlessCacheSnapshotAlreadyExistsFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ServerlessCacheSnapshotNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ServerlessCacheSnapshotNotFoundFault(body.Error, context);
    const exception = new ServerlessCacheSnapshotNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ServerlessCacheSnapshotQuotaExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ServerlessCacheSnapshotQuotaExceededFault(body.Error, context);
    const exception = new ServerlessCacheSnapshotQuotaExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ServiceLinkedRoleNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ServiceLinkedRoleNotFoundFault(body.Error, context);
    const exception = new ServiceLinkedRoleNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ServiceUpdateNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ServiceUpdateNotFoundFault(body.Error, context);
    const exception = new ServiceUpdateNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SnapshotAlreadyExistsFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_SnapshotAlreadyExistsFault(body.Error, context);
    const exception = new SnapshotAlreadyExistsFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SnapshotFeatureNotSupportedFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_SnapshotFeatureNotSupportedFault(body.Error, context);
    const exception = new SnapshotFeatureNotSupportedFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SnapshotNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_SnapshotNotFoundFault(body.Error, context);
    const exception = new SnapshotNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SnapshotQuotaExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_SnapshotQuotaExceededFault(body.Error, context);
    const exception = new SnapshotQuotaExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SubnetInUseRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_SubnetInUse(body.Error, context);
    const exception = new SubnetInUse({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SubnetNotAllowedFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_SubnetNotAllowedFault(body.Error, context);
    const exception = new SubnetNotAllowedFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_TagNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TagNotFoundFault(body.Error, context);
    const exception = new TagNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_TagQuotaPerResourceExceededRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TagQuotaPerResourceExceeded(body.Error, context);
    const exception = new TagQuotaPerResourceExceeded({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_TestFailoverNotAvailableFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TestFailoverNotAvailableFault(body.Error, context);
    const exception = new TestFailoverNotAvailableFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_UserAlreadyExistsFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_UserAlreadyExistsFault(body.Error, context);
    const exception = new UserAlreadyExistsFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_UserGroupAlreadyExistsFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_UserGroupAlreadyExistsFault(body.Error, context);
    const exception = new UserGroupAlreadyExistsFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_UserGroupNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_UserGroupNotFoundFault(body.Error, context);
    const exception = new UserGroupNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_UserGroupQuotaExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_UserGroupQuotaExceededFault(body.Error, context);
    const exception = new UserGroupQuotaExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_UserNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_UserNotFoundFault(body.Error, context);
    const exception = new UserNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_UserQuotaExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_UserQuotaExceededFault(body.Error, context);
    const exception = new UserQuotaExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const se_AddTagsToResourceMessage = (input, context) => {
    const entries = {};
    if (input[_RN] != null) {
        entries[_RN] = input[_RN];
    }
    if (input[_T] != null) {
        const memberEntries = se_TagList(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_AuthenticationMode = (input, context) => {
    const entries = {};
    if (input[_Ty] != null) {
        entries[_Ty] = input[_Ty];
    }
    if (input[_P] != null) {
        const memberEntries = se_PasswordListInput(input[_P], context);
        if (input[_P]?.length === 0) {
            entries.Passwords = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Passwords.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_AuthorizeCacheSecurityGroupIngressMessage = (input, context) => {
    const entries = {};
    if (input[_CSGN] != null) {
        entries[_CSGN] = input[_CSGN];
    }
    if (input[_ECSGN] != null) {
        entries[_ECSGN] = input[_ECSGN];
    }
    if (input[_ECSGOI] != null) {
        entries[_ECSGOI] = input[_ECSGOI];
    }
    return entries;
};
const se_AvailabilityZonesList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`AvailabilityZone.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_BatchApplyUpdateActionMessage = (input, context) => {
    const entries = {};
    if (input[_RGI] != null) {
        const memberEntries = se_ReplicationGroupIdList(input[_RGI], context);
        if (input[_RGI]?.length === 0) {
            entries.ReplicationGroupIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ReplicationGroupIds.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_CCI] != null) {
        const memberEntries = se_CacheClusterIdList(input[_CCI], context);
        if (input[_CCI]?.length === 0) {
            entries.CacheClusterIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CacheClusterIds.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_SUN] != null) {
        entries[_SUN] = input[_SUN];
    }
    return entries;
};
const se_BatchStopUpdateActionMessage = (input, context) => {
    const entries = {};
    if (input[_RGI] != null) {
        const memberEntries = se_ReplicationGroupIdList(input[_RGI], context);
        if (input[_RGI]?.length === 0) {
            entries.ReplicationGroupIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ReplicationGroupIds.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_CCI] != null) {
        const memberEntries = se_CacheClusterIdList(input[_CCI], context);
        if (input[_CCI]?.length === 0) {
            entries.CacheClusterIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CacheClusterIds.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_SUN] != null) {
        entries[_SUN] = input[_SUN];
    }
    return entries;
};
const se_CacheClusterIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_CacheNodeIdsList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`CacheNodeId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_CacheSecurityGroupNameList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`CacheSecurityGroupName.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_CacheUsageLimits = (input, context) => {
    const entries = {};
    if (input[_DSa] != null) {
        const memberEntries = se_DataStorage(input[_DSa], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `DataStorage.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_ECPUPS] != null) {
        const memberEntries = se_ECPUPerSecond(input[_ECPUPS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ECPUPerSecond.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CloudWatchLogsDestinationDetails = (input, context) => {
    const entries = {};
    if (input[_LG] != null) {
        entries[_LG] = input[_LG];
    }
    return entries;
};
const se_CompleteMigrationMessage = (input, context) => {
    const entries = {};
    if (input[_RGIe] != null) {
        entries[_RGIe] = input[_RGIe];
    }
    if (input[_F] != null) {
        entries[_F] = input[_F];
    }
    return entries;
};
const se_ConfigureShard = (input, context) => {
    const entries = {};
    if (input[_NGI] != null) {
        entries[_NGI] = input[_NGI];
    }
    if (input[_NRC] != null) {
        entries[_NRC] = input[_NRC];
    }
    if (input[_PAZ] != null) {
        const memberEntries = se_PreferredAvailabilityZoneList(input[_PAZ], context);
        if (input[_PAZ]?.length === 0) {
            entries.PreferredAvailabilityZones = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PreferredAvailabilityZones.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_POA] != null) {
        const memberEntries = se_PreferredOutpostArnList(input[_POA], context);
        if (input[_POA]?.length === 0) {
            entries.PreferredOutpostArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PreferredOutpostArns.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CopyServerlessCacheSnapshotRequest = (input, context) => {
    const entries = {};
    if (input[_SSCSN] != null) {
        entries[_SSCSN] = input[_SSCSN];
    }
    if (input[_TSCSN] != null) {
        entries[_TSCSN] = input[_TSCSN];
    }
    if (input[_KKI] != null) {
        entries[_KKI] = input[_KKI];
    }
    if (input[_T] != null) {
        const memberEntries = se_TagList(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CopySnapshotMessage = (input, context) => {
    const entries = {};
    if (input[_SSN] != null) {
        entries[_SSN] = input[_SSN];
    }
    if (input[_TSN] != null) {
        entries[_TSN] = input[_TSN];
    }
    if (input[_TB] != null) {
        entries[_TB] = input[_TB];
    }
    if (input[_KKI] != null) {
        entries[_KKI] = input[_KKI];
    }
    if (input[_T] != null) {
        const memberEntries = se_TagList(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateCacheClusterMessage = (input, context) => {
    const entries = {};
    if (input[_CCIa] != null) {
        entries[_CCIa] = input[_CCIa];
    }
    if (input[_RGIe] != null) {
        entries[_RGIe] = input[_RGIe];
    }
    if (input[_AZM] != null) {
        entries[_AZM] = input[_AZM];
    }
    if (input[_PAZr] != null) {
        entries[_PAZr] = input[_PAZr];
    }
    if (input[_PAZ] != null) {
        const memberEntries = se_PreferredAvailabilityZoneList(input[_PAZ], context);
        if (input[_PAZ]?.length === 0) {
            entries.PreferredAvailabilityZones = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PreferredAvailabilityZones.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_NCN] != null) {
        entries[_NCN] = input[_NCN];
    }
    if (input[_CNT] != null) {
        entries[_CNT] = input[_CNT];
    }
    if (input[_E] != null) {
        entries[_E] = input[_E];
    }
    if (input[_EV] != null) {
        entries[_EV] = input[_EV];
    }
    if (input[_CPGN] != null) {
        entries[_CPGN] = input[_CPGN];
    }
    if (input[_CSGNa] != null) {
        entries[_CSGNa] = input[_CSGNa];
    }
    if (input[_CSGNac] != null) {
        const memberEntries = se_CacheSecurityGroupNameList(input[_CSGNac], context);
        if (input[_CSGNac]?.length === 0) {
            entries.CacheSecurityGroupNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CacheSecurityGroupNames.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_SGI] != null) {
        const memberEntries = se_SecurityGroupIdsList(input[_SGI], context);
        if (input[_SGI]?.length === 0) {
            entries.SecurityGroupIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SecurityGroupIds.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_T] != null) {
        const memberEntries = se_TagList(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_SA] != null) {
        const memberEntries = se_SnapshotArnsList(input[_SA], context);
        if (input[_SA]?.length === 0) {
            entries.SnapshotArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SnapshotArns.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_SN] != null) {
        entries[_SN] = input[_SN];
    }
    if (input[_PMW] != null) {
        entries[_PMW] = input[_PMW];
    }
    if (input[_Po] != null) {
        entries[_Po] = input[_Po];
    }
    if (input[_NTA] != null) {
        entries[_NTA] = input[_NTA];
    }
    if (input[_AMVU] != null) {
        entries[_AMVU] = input[_AMVU];
    }
    if (input[_SRL] != null) {
        entries[_SRL] = input[_SRL];
    }
    if (input[_SW] != null) {
        entries[_SW] = input[_SW];
    }
    if (input[_AT] != null) {
        entries[_AT] = input[_AT];
    }
    if (input[_OM] != null) {
        entries[_OM] = input[_OM];
    }
    if (input[_POAr] != null) {
        entries[_POAr] = input[_POAr];
    }
    if (input[_POA] != null) {
        const memberEntries = se_PreferredOutpostArnList(input[_POA], context);
        if (input[_POA]?.length === 0) {
            entries.PreferredOutpostArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PreferredOutpostArns.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_LDC] != null) {
        const memberEntries = se_LogDeliveryConfigurationRequestList(input[_LDC], context);
        if (input[_LDC]?.length === 0) {
            entries.LogDeliveryConfigurations = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LogDeliveryConfigurations.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_TEE] != null) {
        entries[_TEE] = input[_TEE];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_ID] != null) {
        entries[_ID] = input[_ID];
    }
    return entries;
};
const se_CreateCacheParameterGroupMessage = (input, context) => {
    const entries = {};
    if (input[_CPGN] != null) {
        entries[_CPGN] = input[_CPGN];
    }
    if (input[_CPGF] != null) {
        entries[_CPGF] = input[_CPGF];
    }
    if (input[_D] != null) {
        entries[_D] = input[_D];
    }
    if (input[_T] != null) {
        const memberEntries = se_TagList(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateCacheSecurityGroupMessage = (input, context) => {
    const entries = {};
    if (input[_CSGN] != null) {
        entries[_CSGN] = input[_CSGN];
    }
    if (input[_D] != null) {
        entries[_D] = input[_D];
    }
    if (input[_T] != null) {
        const memberEntries = se_TagList(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateCacheSubnetGroupMessage = (input, context) => {
    const entries = {};
    if (input[_CSGNa] != null) {
        entries[_CSGNa] = input[_CSGNa];
    }
    if (input[_CSGD] != null) {
        entries[_CSGD] = input[_CSGD];
    }
    if (input[_SI] != null) {
        const memberEntries = se_SubnetIdentifierList(input[_SI], context);
        if (input[_SI]?.length === 0) {
            entries.SubnetIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SubnetIds.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_T] != null) {
        const memberEntries = se_TagList(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateGlobalReplicationGroupMessage = (input, context) => {
    const entries = {};
    if (input[_GRGIS] != null) {
        entries[_GRGIS] = input[_GRGIS];
    }
    if (input[_GRGD] != null) {
        entries[_GRGD] = input[_GRGD];
    }
    if (input[_PRGI] != null) {
        entries[_PRGI] = input[_PRGI];
    }
    return entries;
};
const se_CreateReplicationGroupMessage = (input, context) => {
    const entries = {};
    if (input[_RGIe] != null) {
        entries[_RGIe] = input[_RGIe];
    }
    if (input[_RGD] != null) {
        entries[_RGD] = input[_RGD];
    }
    if (input[_GRGI] != null) {
        entries[_GRGI] = input[_GRGI];
    }
    if (input[_PCI] != null) {
        entries[_PCI] = input[_PCI];
    }
    if (input[_AFE] != null) {
        entries[_AFE] = input[_AFE];
    }
    if (input[_MAZE] != null) {
        entries[_MAZE] = input[_MAZE];
    }
    if (input[_NCC] != null) {
        entries[_NCC] = input[_NCC];
    }
    if (input[_PCCAZ] != null) {
        const memberEntries = se_AvailabilityZonesList(input[_PCCAZ], context);
        if (input[_PCCAZ]?.length === 0) {
            entries.PreferredCacheClusterAZs = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PreferredCacheClusterAZs.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_NNG] != null) {
        entries[_NNG] = input[_NNG];
    }
    if (input[_RPNG] != null) {
        entries[_RPNG] = input[_RPNG];
    }
    if (input[_NGC] != null) {
        const memberEntries = se_NodeGroupConfigurationList(input[_NGC], context);
        if (input[_NGC]?.length === 0) {
            entries.NodeGroupConfiguration = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `NodeGroupConfiguration.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_CNT] != null) {
        entries[_CNT] = input[_CNT];
    }
    if (input[_E] != null) {
        entries[_E] = input[_E];
    }
    if (input[_EV] != null) {
        entries[_EV] = input[_EV];
    }
    if (input[_CPGN] != null) {
        entries[_CPGN] = input[_CPGN];
    }
    if (input[_CSGNa] != null) {
        entries[_CSGNa] = input[_CSGNa];
    }
    if (input[_CSGNac] != null) {
        const memberEntries = se_CacheSecurityGroupNameList(input[_CSGNac], context);
        if (input[_CSGNac]?.length === 0) {
            entries.CacheSecurityGroupNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CacheSecurityGroupNames.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_SGI] != null) {
        const memberEntries = se_SecurityGroupIdsList(input[_SGI], context);
        if (input[_SGI]?.length === 0) {
            entries.SecurityGroupIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SecurityGroupIds.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_T] != null) {
        const memberEntries = se_TagList(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_SA] != null) {
        const memberEntries = se_SnapshotArnsList(input[_SA], context);
        if (input[_SA]?.length === 0) {
            entries.SnapshotArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SnapshotArns.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_SN] != null) {
        entries[_SN] = input[_SN];
    }
    if (input[_PMW] != null) {
        entries[_PMW] = input[_PMW];
    }
    if (input[_Po] != null) {
        entries[_Po] = input[_Po];
    }
    if (input[_NTA] != null) {
        entries[_NTA] = input[_NTA];
    }
    if (input[_AMVU] != null) {
        entries[_AMVU] = input[_AMVU];
    }
    if (input[_SRL] != null) {
        entries[_SRL] = input[_SRL];
    }
    if (input[_SW] != null) {
        entries[_SW] = input[_SW];
    }
    if (input[_AT] != null) {
        entries[_AT] = input[_AT];
    }
    if (input[_TEE] != null) {
        entries[_TEE] = input[_TEE];
    }
    if (input[_AREE] != null) {
        entries[_AREE] = input[_AREE];
    }
    if (input[_KKI] != null) {
        entries[_KKI] = input[_KKI];
    }
    if (input[_UGI] != null) {
        const memberEntries = se_UserGroupIdListInput(input[_UGI], context);
        if (input[_UGI]?.length === 0) {
            entries.UserGroupIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `UserGroupIds.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_LDC] != null) {
        const memberEntries = se_LogDeliveryConfigurationRequestList(input[_LDC], context);
        if (input[_LDC]?.length === 0) {
            entries.LogDeliveryConfigurations = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LogDeliveryConfigurations.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_DTE] != null) {
        entries[_DTE] = input[_DTE];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_ID] != null) {
        entries[_ID] = input[_ID];
    }
    if (input[_TEM] != null) {
        entries[_TEM] = input[_TEM];
    }
    if (input[_CMl] != null) {
        entries[_CMl] = input[_CMl];
    }
    if (input[_SCSN] != null) {
        entries[_SCSN] = input[_SCSN];
    }
    return entries;
};
const se_CreateServerlessCacheRequest = (input, context) => {
    const entries = {};
    if (input[_SCN] != null) {
        entries[_SCN] = input[_SCN];
    }
    if (input[_D] != null) {
        entries[_D] = input[_D];
    }
    if (input[_E] != null) {
        entries[_E] = input[_E];
    }
    if (input[_MEV] != null) {
        entries[_MEV] = input[_MEV];
    }
    if (input[_CUL] != null) {
        const memberEntries = se_CacheUsageLimits(input[_CUL], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CacheUsageLimits.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_KKI] != null) {
        entries[_KKI] = input[_KKI];
    }
    if (input[_SGI] != null) {
        const memberEntries = se_SecurityGroupIdsList(input[_SGI], context);
        if (input[_SGI]?.length === 0) {
            entries.SecurityGroupIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SecurityGroupIds.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_SATR] != null) {
        const memberEntries = se_SnapshotArnsList(input[_SATR], context);
        if (input[_SATR]?.length === 0) {
            entries.SnapshotArnsToRestore = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SnapshotArnsToRestore.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_T] != null) {
        const memberEntries = se_TagList(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_UGIs] != null) {
        entries[_UGIs] = input[_UGIs];
    }
    if (input[_SI] != null) {
        const memberEntries = se_SubnetIdsList(input[_SI], context);
        if (input[_SI]?.length === 0) {
            entries.SubnetIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SubnetIds.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_SRL] != null) {
        entries[_SRL] = input[_SRL];
    }
    if (input[_DST] != null) {
        entries[_DST] = input[_DST];
    }
    return entries;
};
const se_CreateServerlessCacheSnapshotRequest = (input, context) => {
    const entries = {};
    if (input[_SCSN] != null) {
        entries[_SCSN] = input[_SCSN];
    }
    if (input[_SCN] != null) {
        entries[_SCN] = input[_SCN];
    }
    if (input[_KKI] != null) {
        entries[_KKI] = input[_KKI];
    }
    if (input[_T] != null) {
        const memberEntries = se_TagList(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateSnapshotMessage = (input, context) => {
    const entries = {};
    if (input[_RGIe] != null) {
        entries[_RGIe] = input[_RGIe];
    }
    if (input[_CCIa] != null) {
        entries[_CCIa] = input[_CCIa];
    }
    if (input[_SN] != null) {
        entries[_SN] = input[_SN];
    }
    if (input[_KKI] != null) {
        entries[_KKI] = input[_KKI];
    }
    if (input[_T] != null) {
        const memberEntries = se_TagList(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateUserGroupMessage = (input, context) => {
    const entries = {};
    if (input[_UGIs] != null) {
        entries[_UGIs] = input[_UGIs];
    }
    if (input[_E] != null) {
        entries[_E] = input[_E];
    }
    if (input[_UI] != null) {
        const memberEntries = se_UserIdListInput(input[_UI], context);
        if (input[_UI]?.length === 0) {
            entries.UserIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `UserIds.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_T] != null) {
        const memberEntries = se_TagList(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateUserMessage = (input, context) => {
    const entries = {};
    if (input[_UIs] != null) {
        entries[_UIs] = input[_UIs];
    }
    if (input[_UN] != null) {
        entries[_UN] = input[_UN];
    }
    if (input[_E] != null) {
        entries[_E] = input[_E];
    }
    if (input[_P] != null) {
        const memberEntries = se_PasswordListInput(input[_P], context);
        if (input[_P]?.length === 0) {
            entries.Passwords = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Passwords.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_AS] != null) {
        entries[_AS] = input[_AS];
    }
    if (input[_NPR] != null) {
        entries[_NPR] = input[_NPR];
    }
    if (input[_T] != null) {
        const memberEntries = se_TagList(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_AM] != null) {
        const memberEntries = se_AuthenticationMode(input[_AM], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AuthenticationMode.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CustomerNodeEndpoint = (input, context) => {
    const entries = {};
    if (input[_Ad] != null) {
        entries[_Ad] = input[_Ad];
    }
    if (input[_Po] != null) {
        entries[_Po] = input[_Po];
    }
    return entries;
};
const se_CustomerNodeEndpointList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_CustomerNodeEndpoint(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_DataStorage = (input, context) => {
    const entries = {};
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_Mi] != null) {
        entries[_Mi] = input[_Mi];
    }
    if (input[_U] != null) {
        entries[_U] = input[_U];
    }
    return entries;
};
const se_DecreaseNodeGroupsInGlobalReplicationGroupMessage = (input, context) => {
    const entries = {};
    if (input[_GRGI] != null) {
        entries[_GRGI] = input[_GRGI];
    }
    if (input[_NGCo] != null) {
        entries[_NGCo] = input[_NGCo];
    }
    if (input[_GNGTR] != null) {
        const memberEntries = se_GlobalNodeGroupIdList(input[_GNGTR], context);
        if (input[_GNGTR]?.length === 0) {
            entries.GlobalNodeGroupsToRemove = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `GlobalNodeGroupsToRemove.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_GNGTRl] != null) {
        const memberEntries = se_GlobalNodeGroupIdList(input[_GNGTRl], context);
        if (input[_GNGTRl]?.length === 0) {
            entries.GlobalNodeGroupsToRetain = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `GlobalNodeGroupsToRetain.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_AI] != null) {
        entries[_AI] = input[_AI];
    }
    return entries;
};
const se_DecreaseReplicaCountMessage = (input, context) => {
    const entries = {};
    if (input[_RGIe] != null) {
        entries[_RGIe] = input[_RGIe];
    }
    if (input[_NRC] != null) {
        entries[_NRC] = input[_NRC];
    }
    if (input[_RC] != null) {
        const memberEntries = se_ReplicaConfigurationList(input[_RC], context);
        if (input[_RC]?.length === 0) {
            entries.ReplicaConfiguration = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ReplicaConfiguration.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_RTR] != null) {
        const memberEntries = se_RemoveReplicasList(input[_RTR], context);
        if (input[_RTR]?.length === 0) {
            entries.ReplicasToRemove = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ReplicasToRemove.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_AI] != null) {
        entries[_AI] = input[_AI];
    }
    return entries;
};
const se_DeleteCacheClusterMessage = (input, context) => {
    const entries = {};
    if (input[_CCIa] != null) {
        entries[_CCIa] = input[_CCIa];
    }
    if (input[_FSI] != null) {
        entries[_FSI] = input[_FSI];
    }
    return entries;
};
const se_DeleteCacheParameterGroupMessage = (input, context) => {
    const entries = {};
    if (input[_CPGN] != null) {
        entries[_CPGN] = input[_CPGN];
    }
    return entries;
};
const se_DeleteCacheSecurityGroupMessage = (input, context) => {
    const entries = {};
    if (input[_CSGN] != null) {
        entries[_CSGN] = input[_CSGN];
    }
    return entries;
};
const se_DeleteCacheSubnetGroupMessage = (input, context) => {
    const entries = {};
    if (input[_CSGNa] != null) {
        entries[_CSGNa] = input[_CSGNa];
    }
    return entries;
};
const se_DeleteGlobalReplicationGroupMessage = (input, context) => {
    const entries = {};
    if (input[_GRGI] != null) {
        entries[_GRGI] = input[_GRGI];
    }
    if (input[_RPRG] != null) {
        entries[_RPRG] = input[_RPRG];
    }
    return entries;
};
const se_DeleteReplicationGroupMessage = (input, context) => {
    const entries = {};
    if (input[_RGIe] != null) {
        entries[_RGIe] = input[_RGIe];
    }
    if (input[_RPC] != null) {
        entries[_RPC] = input[_RPC];
    }
    if (input[_FSI] != null) {
        entries[_FSI] = input[_FSI];
    }
    return entries;
};
const se_DeleteServerlessCacheRequest = (input, context) => {
    const entries = {};
    if (input[_SCN] != null) {
        entries[_SCN] = input[_SCN];
    }
    if (input[_FSN] != null) {
        entries[_FSN] = input[_FSN];
    }
    return entries;
};
const se_DeleteServerlessCacheSnapshotRequest = (input, context) => {
    const entries = {};
    if (input[_SCSN] != null) {
        entries[_SCSN] = input[_SCSN];
    }
    return entries;
};
const se_DeleteSnapshotMessage = (input, context) => {
    const entries = {};
    if (input[_SN] != null) {
        entries[_SN] = input[_SN];
    }
    return entries;
};
const se_DeleteUserGroupMessage = (input, context) => {
    const entries = {};
    if (input[_UGIs] != null) {
        entries[_UGIs] = input[_UGIs];
    }
    return entries;
};
const se_DeleteUserMessage = (input, context) => {
    const entries = {};
    if (input[_UIs] != null) {
        entries[_UIs] = input[_UIs];
    }
    return entries;
};
const se_DescribeCacheClustersMessage = (input, context) => {
    const entries = {};
    if (input[_CCIa] != null) {
        entries[_CCIa] = input[_CCIa];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_Ma] != null) {
        entries[_Ma] = input[_Ma];
    }
    if (input[_SCNI] != null) {
        entries[_SCNI] = input[_SCNI];
    }
    if (input[_SCCNIRG] != null) {
        entries[_SCCNIRG] = input[_SCCNIRG];
    }
    return entries;
};
const se_DescribeCacheEngineVersionsMessage = (input, context) => {
    const entries = {};
    if (input[_E] != null) {
        entries[_E] = input[_E];
    }
    if (input[_EV] != null) {
        entries[_EV] = input[_EV];
    }
    if (input[_CPGF] != null) {
        entries[_CPGF] = input[_CPGF];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_Ma] != null) {
        entries[_Ma] = input[_Ma];
    }
    if (input[_DO] != null) {
        entries[_DO] = input[_DO];
    }
    return entries;
};
const se_DescribeCacheParameterGroupsMessage = (input, context) => {
    const entries = {};
    if (input[_CPGN] != null) {
        entries[_CPGN] = input[_CPGN];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_Ma] != null) {
        entries[_Ma] = input[_Ma];
    }
    return entries;
};
const se_DescribeCacheParametersMessage = (input, context) => {
    const entries = {};
    if (input[_CPGN] != null) {
        entries[_CPGN] = input[_CPGN];
    }
    if (input[_S] != null) {
        entries[_S] = input[_S];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_Ma] != null) {
        entries[_Ma] = input[_Ma];
    }
    return entries;
};
const se_DescribeCacheSecurityGroupsMessage = (input, context) => {
    const entries = {};
    if (input[_CSGN] != null) {
        entries[_CSGN] = input[_CSGN];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_Ma] != null) {
        entries[_Ma] = input[_Ma];
    }
    return entries;
};
const se_DescribeCacheSubnetGroupsMessage = (input, context) => {
    const entries = {};
    if (input[_CSGNa] != null) {
        entries[_CSGNa] = input[_CSGNa];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_Ma] != null) {
        entries[_Ma] = input[_Ma];
    }
    return entries;
};
const se_DescribeEngineDefaultParametersMessage = (input, context) => {
    const entries = {};
    if (input[_CPGF] != null) {
        entries[_CPGF] = input[_CPGF];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_Ma] != null) {
        entries[_Ma] = input[_Ma];
    }
    return entries;
};
const se_DescribeEventsMessage = (input, context) => {
    const entries = {};
    if (input[_SIo] != null) {
        entries[_SIo] = input[_SIo];
    }
    if (input[_ST] != null) {
        entries[_ST] = input[_ST];
    }
    if (input[_STt] != null) {
        entries[_STt] = __serializeDateTime(input[_STt]);
    }
    if (input[_ET] != null) {
        entries[_ET] = __serializeDateTime(input[_ET]);
    }
    if (input[_Du] != null) {
        entries[_Du] = input[_Du];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_Ma] != null) {
        entries[_Ma] = input[_Ma];
    }
    return entries;
};
const se_DescribeGlobalReplicationGroupsMessage = (input, context) => {
    const entries = {};
    if (input[_GRGI] != null) {
        entries[_GRGI] = input[_GRGI];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_Ma] != null) {
        entries[_Ma] = input[_Ma];
    }
    if (input[_SMI] != null) {
        entries[_SMI] = input[_SMI];
    }
    return entries;
};
const se_DescribeReplicationGroupsMessage = (input, context) => {
    const entries = {};
    if (input[_RGIe] != null) {
        entries[_RGIe] = input[_RGIe];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_Ma] != null) {
        entries[_Ma] = input[_Ma];
    }
    return entries;
};
const se_DescribeReservedCacheNodesMessage = (input, context) => {
    const entries = {};
    if (input[_RCNI] != null) {
        entries[_RCNI] = input[_RCNI];
    }
    if (input[_RCNOI] != null) {
        entries[_RCNOI] = input[_RCNOI];
    }
    if (input[_CNT] != null) {
        entries[_CNT] = input[_CNT];
    }
    if (input[_Du] != null) {
        entries[_Du] = input[_Du];
    }
    if (input[_PD] != null) {
        entries[_PD] = input[_PD];
    }
    if (input[_OT] != null) {
        entries[_OT] = input[_OT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_Ma] != null) {
        entries[_Ma] = input[_Ma];
    }
    return entries;
};
const se_DescribeReservedCacheNodesOfferingsMessage = (input, context) => {
    const entries = {};
    if (input[_RCNOI] != null) {
        entries[_RCNOI] = input[_RCNOI];
    }
    if (input[_CNT] != null) {
        entries[_CNT] = input[_CNT];
    }
    if (input[_Du] != null) {
        entries[_Du] = input[_Du];
    }
    if (input[_PD] != null) {
        entries[_PD] = input[_PD];
    }
    if (input[_OT] != null) {
        entries[_OT] = input[_OT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_Ma] != null) {
        entries[_Ma] = input[_Ma];
    }
    return entries;
};
const se_DescribeServerlessCacheSnapshotsRequest = (input, context) => {
    const entries = {};
    if (input[_SCN] != null) {
        entries[_SCN] = input[_SCN];
    }
    if (input[_SCSN] != null) {
        entries[_SCSN] = input[_SCSN];
    }
    if (input[_STn] != null) {
        entries[_STn] = input[_STn];
    }
    if (input[_NTe] != null) {
        entries[_NTe] = input[_NTe];
    }
    if (input[_MRa] != null) {
        entries[_MRa] = input[_MRa];
    }
    return entries;
};
const se_DescribeServerlessCachesRequest = (input, context) => {
    const entries = {};
    if (input[_SCN] != null) {
        entries[_SCN] = input[_SCN];
    }
    if (input[_MRa] != null) {
        entries[_MRa] = input[_MRa];
    }
    if (input[_NTe] != null) {
        entries[_NTe] = input[_NTe];
    }
    return entries;
};
const se_DescribeServiceUpdatesMessage = (input, context) => {
    const entries = {};
    if (input[_SUN] != null) {
        entries[_SUN] = input[_SUN];
    }
    if (input[_SUS] != null) {
        const memberEntries = se_ServiceUpdateStatusList(input[_SUS], context);
        if (input[_SUS]?.length === 0) {
            entries.ServiceUpdateStatus = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ServiceUpdateStatus.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_Ma] != null) {
        entries[_Ma] = input[_Ma];
    }
    return entries;
};
const se_DescribeSnapshotsMessage = (input, context) => {
    const entries = {};
    if (input[_RGIe] != null) {
        entries[_RGIe] = input[_RGIe];
    }
    if (input[_CCIa] != null) {
        entries[_CCIa] = input[_CCIa];
    }
    if (input[_SN] != null) {
        entries[_SN] = input[_SN];
    }
    if (input[_SS] != null) {
        entries[_SS] = input[_SS];
    }
    if (input[_Ma] != null) {
        entries[_Ma] = input[_Ma];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_SNGC] != null) {
        entries[_SNGC] = input[_SNGC];
    }
    return entries;
};
const se_DescribeUpdateActionsMessage = (input, context) => {
    const entries = {};
    if (input[_SUN] != null) {
        entries[_SUN] = input[_SUN];
    }
    if (input[_RGI] != null) {
        const memberEntries = se_ReplicationGroupIdList(input[_RGI], context);
        if (input[_RGI]?.length === 0) {
            entries.ReplicationGroupIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ReplicationGroupIds.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_CCI] != null) {
        const memberEntries = se_CacheClusterIdList(input[_CCI], context);
        if (input[_CCI]?.length === 0) {
            entries.CacheClusterIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CacheClusterIds.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_E] != null) {
        entries[_E] = input[_E];
    }
    if (input[_SUS] != null) {
        const memberEntries = se_ServiceUpdateStatusList(input[_SUS], context);
        if (input[_SUS]?.length === 0) {
            entries.ServiceUpdateStatus = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ServiceUpdateStatus.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_SUTR] != null) {
        const memberEntries = se_TimeRangeFilter(input[_SUTR], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ServiceUpdateTimeRange.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_UAS] != null) {
        const memberEntries = se_UpdateActionStatusList(input[_UAS], context);
        if (input[_UAS]?.length === 0) {
            entries.UpdateActionStatus = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `UpdateActionStatus.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_SNLUS] != null) {
        entries[_SNLUS] = input[_SNLUS];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_Ma] != null) {
        entries[_Ma] = input[_Ma];
    }
    return entries;
};
const se_DescribeUserGroupsMessage = (input, context) => {
    const entries = {};
    if (input[_UGIs] != null) {
        entries[_UGIs] = input[_UGIs];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_Ma] != null) {
        entries[_Ma] = input[_Ma];
    }
    return entries;
};
const se_DescribeUsersMessage = (input, context) => {
    const entries = {};
    if (input[_E] != null) {
        entries[_E] = input[_E];
    }
    if (input[_UIs] != null) {
        entries[_UIs] = input[_UIs];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        if (input[_Fi]?.length === 0) {
            entries.Filters = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filters.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_Ma] != null) {
        entries[_Ma] = input[_Ma];
    }
    return entries;
};
const se_DestinationDetails = (input, context) => {
    const entries = {};
    if (input[_CWLD] != null) {
        const memberEntries = se_CloudWatchLogsDestinationDetails(input[_CWLD], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CloudWatchLogsDetails.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_KFD] != null) {
        const memberEntries = se_KinesisFirehoseDestinationDetails(input[_KFD], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `KinesisFirehoseDetails.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DisassociateGlobalReplicationGroupMessage = (input, context) => {
    const entries = {};
    if (input[_GRGI] != null) {
        entries[_GRGI] = input[_GRGI];
    }
    if (input[_RGIe] != null) {
        entries[_RGIe] = input[_RGIe];
    }
    if (input[_RGR] != null) {
        entries[_RGR] = input[_RGR];
    }
    return entries;
};
const se_ECPUPerSecond = (input, context) => {
    const entries = {};
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_Mi] != null) {
        entries[_Mi] = input[_Mi];
    }
    return entries;
};
const se_ExportServerlessCacheSnapshotRequest = (input, context) => {
    const entries = {};
    if (input[_SCSN] != null) {
        entries[_SCSN] = input[_SCSN];
    }
    if (input[_SBN] != null) {
        entries[_SBN] = input[_SBN];
    }
    return entries;
};
const se_FailoverGlobalReplicationGroupMessage = (input, context) => {
    const entries = {};
    if (input[_GRGI] != null) {
        entries[_GRGI] = input[_GRGI];
    }
    if (input[_PR] != null) {
        entries[_PR] = input[_PR];
    }
    if (input[_PRGI] != null) {
        entries[_PRGI] = input[_PRGI];
    }
    return entries;
};
const se_Filter = (input, context) => {
    const entries = {};
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    if (input[_Va] != null) {
        const memberEntries = se_FilterValueList(input[_Va], context);
        if (input[_Va]?.length === 0) {
            entries.Values = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Values.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_FilterList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_Filter(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_FilterValueList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_GlobalNodeGroupIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`GlobalNodeGroupId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_IncreaseNodeGroupsInGlobalReplicationGroupMessage = (input, context) => {
    const entries = {};
    if (input[_GRGI] != null) {
        entries[_GRGI] = input[_GRGI];
    }
    if (input[_NGCo] != null) {
        entries[_NGCo] = input[_NGCo];
    }
    if (input[_RCe] != null) {
        const memberEntries = se_RegionalConfigurationList(input[_RCe], context);
        if (input[_RCe]?.length === 0) {
            entries.RegionalConfigurations = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RegionalConfigurations.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_AI] != null) {
        entries[_AI] = input[_AI];
    }
    return entries;
};
const se_IncreaseReplicaCountMessage = (input, context) => {
    const entries = {};
    if (input[_RGIe] != null) {
        entries[_RGIe] = input[_RGIe];
    }
    if (input[_NRC] != null) {
        entries[_NRC] = input[_NRC];
    }
    if (input[_RC] != null) {
        const memberEntries = se_ReplicaConfigurationList(input[_RC], context);
        if (input[_RC]?.length === 0) {
            entries.ReplicaConfiguration = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ReplicaConfiguration.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_AI] != null) {
        entries[_AI] = input[_AI];
    }
    return entries;
};
const se_KeyList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_KinesisFirehoseDestinationDetails = (input, context) => {
    const entries = {};
    if (input[_DSel] != null) {
        entries[_DSel] = input[_DSel];
    }
    return entries;
};
const se_ListAllowedNodeTypeModificationsMessage = (input, context) => {
    const entries = {};
    if (input[_CCIa] != null) {
        entries[_CCIa] = input[_CCIa];
    }
    if (input[_RGIe] != null) {
        entries[_RGIe] = input[_RGIe];
    }
    return entries;
};
const se_ListTagsForResourceMessage = (input, context) => {
    const entries = {};
    if (input[_RN] != null) {
        entries[_RN] = input[_RN];
    }
    return entries;
};
const se_LogDeliveryConfigurationRequest = (input, context) => {
    const entries = {};
    if (input[_LT] != null) {
        entries[_LT] = input[_LT];
    }
    if (input[_DT] != null) {
        entries[_DT] = input[_DT];
    }
    if (input[_DD] != null) {
        const memberEntries = se_DestinationDetails(input[_DD], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `DestinationDetails.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_LF] != null) {
        entries[_LF] = input[_LF];
    }
    if (input[_En] != null) {
        entries[_En] = input[_En];
    }
    return entries;
};
const se_LogDeliveryConfigurationRequestList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_LogDeliveryConfigurationRequest(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`LogDeliveryConfigurationRequest.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_ModifyCacheClusterMessage = (input, context) => {
    const entries = {};
    if (input[_CCIa] != null) {
        entries[_CCIa] = input[_CCIa];
    }
    if (input[_NCN] != null) {
        entries[_NCN] = input[_NCN];
    }
    if (input[_CNITR] != null) {
        const memberEntries = se_CacheNodeIdsList(input[_CNITR], context);
        if (input[_CNITR]?.length === 0) {
            entries.CacheNodeIdsToRemove = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CacheNodeIdsToRemove.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_AZM] != null) {
        entries[_AZM] = input[_AZM];
    }
    if (input[_NAZ] != null) {
        const memberEntries = se_PreferredAvailabilityZoneList(input[_NAZ], context);
        if (input[_NAZ]?.length === 0) {
            entries.NewAvailabilityZones = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `NewAvailabilityZones.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_CSGNac] != null) {
        const memberEntries = se_CacheSecurityGroupNameList(input[_CSGNac], context);
        if (input[_CSGNac]?.length === 0) {
            entries.CacheSecurityGroupNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CacheSecurityGroupNames.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_SGI] != null) {
        const memberEntries = se_SecurityGroupIdsList(input[_SGI], context);
        if (input[_SGI]?.length === 0) {
            entries.SecurityGroupIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SecurityGroupIds.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_PMW] != null) {
        entries[_PMW] = input[_PMW];
    }
    if (input[_NTA] != null) {
        entries[_NTA] = input[_NTA];
    }
    if (input[_CPGN] != null) {
        entries[_CPGN] = input[_CPGN];
    }
    if (input[_NTS] != null) {
        entries[_NTS] = input[_NTS];
    }
    if (input[_AI] != null) {
        entries[_AI] = input[_AI];
    }
    if (input[_E] != null) {
        entries[_E] = input[_E];
    }
    if (input[_EV] != null) {
        entries[_EV] = input[_EV];
    }
    if (input[_AMVU] != null) {
        entries[_AMVU] = input[_AMVU];
    }
    if (input[_SRL] != null) {
        entries[_SRL] = input[_SRL];
    }
    if (input[_SW] != null) {
        entries[_SW] = input[_SW];
    }
    if (input[_CNT] != null) {
        entries[_CNT] = input[_CNT];
    }
    if (input[_AT] != null) {
        entries[_AT] = input[_AT];
    }
    if (input[_ATUS] != null) {
        entries[_ATUS] = input[_ATUS];
    }
    if (input[_LDC] != null) {
        const memberEntries = se_LogDeliveryConfigurationRequestList(input[_LDC], context);
        if (input[_LDC]?.length === 0) {
            entries.LogDeliveryConfigurations = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LogDeliveryConfigurations.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_ID] != null) {
        entries[_ID] = input[_ID];
    }
    return entries;
};
const se_ModifyCacheParameterGroupMessage = (input, context) => {
    const entries = {};
    if (input[_CPGN] != null) {
        entries[_CPGN] = input[_CPGN];
    }
    if (input[_PNV] != null) {
        const memberEntries = se_ParameterNameValueList(input[_PNV], context);
        if (input[_PNV]?.length === 0) {
            entries.ParameterNameValues = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ParameterNameValues.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ModifyCacheSubnetGroupMessage = (input, context) => {
    const entries = {};
    if (input[_CSGNa] != null) {
        entries[_CSGNa] = input[_CSGNa];
    }
    if (input[_CSGD] != null) {
        entries[_CSGD] = input[_CSGD];
    }
    if (input[_SI] != null) {
        const memberEntries = se_SubnetIdentifierList(input[_SI], context);
        if (input[_SI]?.length === 0) {
            entries.SubnetIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SubnetIds.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ModifyGlobalReplicationGroupMessage = (input, context) => {
    const entries = {};
    if (input[_GRGI] != null) {
        entries[_GRGI] = input[_GRGI];
    }
    if (input[_AI] != null) {
        entries[_AI] = input[_AI];
    }
    if (input[_CNT] != null) {
        entries[_CNT] = input[_CNT];
    }
    if (input[_E] != null) {
        entries[_E] = input[_E];
    }
    if (input[_EV] != null) {
        entries[_EV] = input[_EV];
    }
    if (input[_CPGN] != null) {
        entries[_CPGN] = input[_CPGN];
    }
    if (input[_GRGD] != null) {
        entries[_GRGD] = input[_GRGD];
    }
    if (input[_AFE] != null) {
        entries[_AFE] = input[_AFE];
    }
    return entries;
};
const se_ModifyReplicationGroupMessage = (input, context) => {
    const entries = {};
    if (input[_RGIe] != null) {
        entries[_RGIe] = input[_RGIe];
    }
    if (input[_RGD] != null) {
        entries[_RGD] = input[_RGD];
    }
    if (input[_PCI] != null) {
        entries[_PCI] = input[_PCI];
    }
    if (input[_SCI] != null) {
        entries[_SCI] = input[_SCI];
    }
    if (input[_AFE] != null) {
        entries[_AFE] = input[_AFE];
    }
    if (input[_MAZE] != null) {
        entries[_MAZE] = input[_MAZE];
    }
    if (input[_NGI] != null) {
        entries[_NGI] = input[_NGI];
    }
    if (input[_CSGNac] != null) {
        const memberEntries = se_CacheSecurityGroupNameList(input[_CSGNac], context);
        if (input[_CSGNac]?.length === 0) {
            entries.CacheSecurityGroupNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CacheSecurityGroupNames.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_SGI] != null) {
        const memberEntries = se_SecurityGroupIdsList(input[_SGI], context);
        if (input[_SGI]?.length === 0) {
            entries.SecurityGroupIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SecurityGroupIds.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_PMW] != null) {
        entries[_PMW] = input[_PMW];
    }
    if (input[_NTA] != null) {
        entries[_NTA] = input[_NTA];
    }
    if (input[_CPGN] != null) {
        entries[_CPGN] = input[_CPGN];
    }
    if (input[_NTS] != null) {
        entries[_NTS] = input[_NTS];
    }
    if (input[_AI] != null) {
        entries[_AI] = input[_AI];
    }
    if (input[_E] != null) {
        entries[_E] = input[_E];
    }
    if (input[_EV] != null) {
        entries[_EV] = input[_EV];
    }
    if (input[_AMVU] != null) {
        entries[_AMVU] = input[_AMVU];
    }
    if (input[_SRL] != null) {
        entries[_SRL] = input[_SRL];
    }
    if (input[_SW] != null) {
        entries[_SW] = input[_SW];
    }
    if (input[_CNT] != null) {
        entries[_CNT] = input[_CNT];
    }
    if (input[_AT] != null) {
        entries[_AT] = input[_AT];
    }
    if (input[_ATUS] != null) {
        entries[_ATUS] = input[_ATUS];
    }
    if (input[_UGITA] != null) {
        const memberEntries = se_UserGroupIdList(input[_UGITA], context);
        if (input[_UGITA]?.length === 0) {
            entries.UserGroupIdsToAdd = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `UserGroupIdsToAdd.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_UGITR] != null) {
        const memberEntries = se_UserGroupIdList(input[_UGITR], context);
        if (input[_UGITR]?.length === 0) {
            entries.UserGroupIdsToRemove = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `UserGroupIdsToRemove.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_RUG] != null) {
        entries[_RUG] = input[_RUG];
    }
    if (input[_LDC] != null) {
        const memberEntries = se_LogDeliveryConfigurationRequestList(input[_LDC], context);
        if (input[_LDC]?.length === 0) {
            entries.LogDeliveryConfigurations = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LogDeliveryConfigurations.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_ID] != null) {
        entries[_ID] = input[_ID];
    }
    if (input[_TEE] != null) {
        entries[_TEE] = input[_TEE];
    }
    if (input[_TEM] != null) {
        entries[_TEM] = input[_TEM];
    }
    if (input[_CMl] != null) {
        entries[_CMl] = input[_CMl];
    }
    return entries;
};
const se_ModifyReplicationGroupShardConfigurationMessage = (input, context) => {
    const entries = {};
    if (input[_RGIe] != null) {
        entries[_RGIe] = input[_RGIe];
    }
    if (input[_NGCo] != null) {
        entries[_NGCo] = input[_NGCo];
    }
    if (input[_AI] != null) {
        entries[_AI] = input[_AI];
    }
    if (input[_RCes] != null) {
        const memberEntries = se_ReshardingConfigurationList(input[_RCes], context);
        if (input[_RCes]?.length === 0) {
            entries.ReshardingConfiguration = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ReshardingConfiguration.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_NGTR] != null) {
        const memberEntries = se_NodeGroupsToRemoveList(input[_NGTR], context);
        if (input[_NGTR]?.length === 0) {
            entries.NodeGroupsToRemove = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `NodeGroupsToRemove.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_NGTRo] != null) {
        const memberEntries = se_NodeGroupsToRetainList(input[_NGTRo], context);
        if (input[_NGTRo]?.length === 0) {
            entries.NodeGroupsToRetain = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `NodeGroupsToRetain.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ModifyServerlessCacheRequest = (input, context) => {
    const entries = {};
    if (input[_SCN] != null) {
        entries[_SCN] = input[_SCN];
    }
    if (input[_D] != null) {
        entries[_D] = input[_D];
    }
    if (input[_CUL] != null) {
        const memberEntries = se_CacheUsageLimits(input[_CUL], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CacheUsageLimits.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_RUGe] != null) {
        entries[_RUGe] = input[_RUGe];
    }
    if (input[_UGIs] != null) {
        entries[_UGIs] = input[_UGIs];
    }
    if (input[_SGI] != null) {
        const memberEntries = se_SecurityGroupIdsList(input[_SGI], context);
        if (input[_SGI]?.length === 0) {
            entries.SecurityGroupIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SecurityGroupIds.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_SRL] != null) {
        entries[_SRL] = input[_SRL];
    }
    if (input[_DST] != null) {
        entries[_DST] = input[_DST];
    }
    if (input[_E] != null) {
        entries[_E] = input[_E];
    }
    if (input[_MEV] != null) {
        entries[_MEV] = input[_MEV];
    }
    return entries;
};
const se_ModifyUserGroupMessage = (input, context) => {
    const entries = {};
    if (input[_UGIs] != null) {
        entries[_UGIs] = input[_UGIs];
    }
    if (input[_UITA] != null) {
        const memberEntries = se_UserIdListInput(input[_UITA], context);
        if (input[_UITA]?.length === 0) {
            entries.UserIdsToAdd = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `UserIdsToAdd.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_UITR] != null) {
        const memberEntries = se_UserIdListInput(input[_UITR], context);
        if (input[_UITR]?.length === 0) {
            entries.UserIdsToRemove = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `UserIdsToRemove.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_E] != null) {
        entries[_E] = input[_E];
    }
    return entries;
};
const se_ModifyUserMessage = (input, context) => {
    const entries = {};
    if (input[_UIs] != null) {
        entries[_UIs] = input[_UIs];
    }
    if (input[_AS] != null) {
        entries[_AS] = input[_AS];
    }
    if (input[_AAS] != null) {
        entries[_AAS] = input[_AAS];
    }
    if (input[_P] != null) {
        const memberEntries = se_PasswordListInput(input[_P], context);
        if (input[_P]?.length === 0) {
            entries.Passwords = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Passwords.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_NPR] != null) {
        entries[_NPR] = input[_NPR];
    }
    if (input[_AM] != null) {
        const memberEntries = se_AuthenticationMode(input[_AM], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AuthenticationMode.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_E] != null) {
        entries[_E] = input[_E];
    }
    return entries;
};
const se_NodeGroupConfiguration = (input, context) => {
    const entries = {};
    if (input[_NGI] != null) {
        entries[_NGI] = input[_NGI];
    }
    if (input[_Sl] != null) {
        entries[_Sl] = input[_Sl];
    }
    if (input[_RCep] != null) {
        entries[_RCep] = input[_RCep];
    }
    if (input[_PAZri] != null) {
        entries[_PAZri] = input[_PAZri];
    }
    if (input[_RAZ] != null) {
        const memberEntries = se_AvailabilityZonesList(input[_RAZ], context);
        if (input[_RAZ]?.length === 0) {
            entries.ReplicaAvailabilityZones = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ReplicaAvailabilityZones.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_POAri] != null) {
        entries[_POAri] = input[_POAri];
    }
    if (input[_ROA] != null) {
        const memberEntries = se_OutpostArnsList(input[_ROA], context);
        if (input[_ROA]?.length === 0) {
            entries.ReplicaOutpostArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ReplicaOutpostArns.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_NodeGroupConfigurationList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_NodeGroupConfiguration(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`NodeGroupConfiguration.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_NodeGroupsToRemoveList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`NodeGroupToRemove.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_NodeGroupsToRetainList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`NodeGroupToRetain.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_OutpostArnsList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`OutpostArn.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ParameterNameValue = (input, context) => {
    const entries = {};
    if (input[_PN] != null) {
        entries[_PN] = input[_PN];
    }
    if (input[_PV] != null) {
        entries[_PV] = input[_PV];
    }
    return entries;
};
const se_ParameterNameValueList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_ParameterNameValue(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`ParameterNameValue.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_PasswordListInput = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_PreferredAvailabilityZoneList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`PreferredAvailabilityZone.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_PreferredOutpostArnList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`PreferredOutpostArn.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_PurchaseReservedCacheNodesOfferingMessage = (input, context) => {
    const entries = {};
    if (input[_RCNOI] != null) {
        entries[_RCNOI] = input[_RCNOI];
    }
    if (input[_RCNI] != null) {
        entries[_RCNI] = input[_RCNI];
    }
    if (input[_CNC] != null) {
        entries[_CNC] = input[_CNC];
    }
    if (input[_T] != null) {
        const memberEntries = se_TagList(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_RebalanceSlotsInGlobalReplicationGroupMessage = (input, context) => {
    const entries = {};
    if (input[_GRGI] != null) {
        entries[_GRGI] = input[_GRGI];
    }
    if (input[_AI] != null) {
        entries[_AI] = input[_AI];
    }
    return entries;
};
const se_RebootCacheClusterMessage = (input, context) => {
    const entries = {};
    if (input[_CCIa] != null) {
        entries[_CCIa] = input[_CCIa];
    }
    if (input[_CNITRa] != null) {
        const memberEntries = se_CacheNodeIdsList(input[_CNITRa], context);
        if (input[_CNITRa]?.length === 0) {
            entries.CacheNodeIdsToReboot = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CacheNodeIdsToReboot.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_RegionalConfiguration = (input, context) => {
    const entries = {};
    if (input[_RGIe] != null) {
        entries[_RGIe] = input[_RGIe];
    }
    if (input[_RGR] != null) {
        entries[_RGR] = input[_RGR];
    }
    if (input[_RCes] != null) {
        const memberEntries = se_ReshardingConfigurationList(input[_RCes], context);
        if (input[_RCes]?.length === 0) {
            entries.ReshardingConfiguration = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ReshardingConfiguration.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_RegionalConfigurationList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_RegionalConfiguration(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`RegionalConfiguration.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_RemoveReplicasList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_RemoveTagsFromResourceMessage = (input, context) => {
    const entries = {};
    if (input[_RN] != null) {
        entries[_RN] = input[_RN];
    }
    if (input[_TK] != null) {
        const memberEntries = se_KeyList(input[_TK], context);
        if (input[_TK]?.length === 0) {
            entries.TagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagKeys.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ReplicaConfigurationList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_ConfigureShard(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`ConfigureShard.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_ReplicationGroupIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ResetCacheParameterGroupMessage = (input, context) => {
    const entries = {};
    if (input[_CPGN] != null) {
        entries[_CPGN] = input[_CPGN];
    }
    if (input[_RAP] != null) {
        entries[_RAP] = input[_RAP];
    }
    if (input[_PNV] != null) {
        const memberEntries = se_ParameterNameValueList(input[_PNV], context);
        if (input[_PNV]?.length === 0) {
            entries.ParameterNameValues = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ParameterNameValues.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ReshardingConfiguration = (input, context) => {
    const entries = {};
    if (input[_NGI] != null) {
        entries[_NGI] = input[_NGI];
    }
    if (input[_PAZ] != null) {
        const memberEntries = se_AvailabilityZonesList(input[_PAZ], context);
        if (input[_PAZ]?.length === 0) {
            entries.PreferredAvailabilityZones = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PreferredAvailabilityZones.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ReshardingConfigurationList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_ReshardingConfiguration(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`ReshardingConfiguration.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_RevokeCacheSecurityGroupIngressMessage = (input, context) => {
    const entries = {};
    if (input[_CSGN] != null) {
        entries[_CSGN] = input[_CSGN];
    }
    if (input[_ECSGN] != null) {
        entries[_ECSGN] = input[_ECSGN];
    }
    if (input[_ECSGOI] != null) {
        entries[_ECSGOI] = input[_ECSGOI];
    }
    return entries;
};
const se_SecurityGroupIdsList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`SecurityGroupId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ServiceUpdateStatusList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_SnapshotArnsList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`SnapshotArn.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_StartMigrationMessage = (input, context) => {
    const entries = {};
    if (input[_RGIe] != null) {
        entries[_RGIe] = input[_RGIe];
    }
    if (input[_CNEL] != null) {
        const memberEntries = se_CustomerNodeEndpointList(input[_CNEL], context);
        if (input[_CNEL]?.length === 0) {
            entries.CustomerNodeEndpointList = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CustomerNodeEndpointList.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_SubnetIdentifierList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`SubnetIdentifier.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_SubnetIdsList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`SubnetId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_Tag = (input, context) => {
    const entries = {};
    if (input[_K] != null) {
        entries[_K] = input[_K];
    }
    if (input[_Val] != null) {
        entries[_Val] = input[_Val];
    }
    return entries;
};
const se_TagList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_Tag(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Tag.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_TestFailoverMessage = (input, context) => {
    const entries = {};
    if (input[_RGIe] != null) {
        entries[_RGIe] = input[_RGIe];
    }
    if (input[_NGI] != null) {
        entries[_NGI] = input[_NGI];
    }
    return entries;
};
const se_TestMigrationMessage = (input, context) => {
    const entries = {};
    if (input[_RGIe] != null) {
        entries[_RGIe] = input[_RGIe];
    }
    if (input[_CNEL] != null) {
        const memberEntries = se_CustomerNodeEndpointList(input[_CNEL], context);
        if (input[_CNEL]?.length === 0) {
            entries.CustomerNodeEndpointList = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CustomerNodeEndpointList.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_TimeRangeFilter = (input, context) => {
    const entries = {};
    if (input[_STt] != null) {
        entries[_STt] = __serializeDateTime(input[_STt]);
    }
    if (input[_ET] != null) {
        entries[_ET] = __serializeDateTime(input[_ET]);
    }
    return entries;
};
const se_UpdateActionStatusList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_UserGroupIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_UserGroupIdListInput = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_UserIdListInput = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const de_AllowedNodeTypeModificationsMessage = (output, context) => {
    const contents = {};
    if (output.ScaleUpModifications === "") {
        contents[_SUM] = [];
    }
    else if (output[_SUM] != null && output[_SUM][_m] != null) {
        contents[_SUM] = de_NodeTypeList(__getArrayIfSingleItem(output[_SUM][_m]), context);
    }
    if (output.ScaleDownModifications === "") {
        contents[_SDM] = [];
    }
    else if (output[_SDM] != null && output[_SDM][_m] != null) {
        contents[_SDM] = de_NodeTypeList(__getArrayIfSingleItem(output[_SDM][_m]), context);
    }
    return contents;
};
const de_APICallRateForCustomerExceededFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_Authentication = (output, context) => {
    const contents = {};
    if (output[_Ty] != null) {
        contents[_Ty] = __expectString(output[_Ty]);
    }
    if (output[_PC] != null) {
        contents[_PC] = __strictParseInt32(output[_PC]);
    }
    return contents;
};
const de_AuthorizationAlreadyExistsFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_AuthorizationNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_AuthorizeCacheSecurityGroupIngressResult = (output, context) => {
    const contents = {};
    if (output[_CSG] != null) {
        contents[_CSG] = de_CacheSecurityGroup(output[_CSG], context);
    }
    return contents;
};
const de_AvailabilityZone = (output, context) => {
    const contents = {};
    if (output[_N] != null) {
        contents[_N] = __expectString(output[_N]);
    }
    return contents;
};
const de_AvailabilityZonesList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_CacheCluster = (output, context) => {
    const contents = {};
    if (output[_CCIa] != null) {
        contents[_CCIa] = __expectString(output[_CCIa]);
    }
    if (output[_CE] != null) {
        contents[_CE] = de_Endpoint(output[_CE], context);
    }
    if (output[_CDLP] != null) {
        contents[_CDLP] = __expectString(output[_CDLP]);
    }
    if (output[_CNT] != null) {
        contents[_CNT] = __expectString(output[_CNT]);
    }
    if (output[_E] != null) {
        contents[_E] = __expectString(output[_E]);
    }
    if (output[_EV] != null) {
        contents[_EV] = __expectString(output[_EV]);
    }
    if (output[_CCS] != null) {
        contents[_CCS] = __expectString(output[_CCS]);
    }
    if (output[_NCN] != null) {
        contents[_NCN] = __strictParseInt32(output[_NCN]);
    }
    if (output[_PAZr] != null) {
        contents[_PAZr] = __expectString(output[_PAZr]);
    }
    if (output[_POAr] != null) {
        contents[_POAr] = __expectString(output[_POAr]);
    }
    if (output[_CCCT] != null) {
        contents[_CCCT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_CCCT]));
    }
    if (output[_PMW] != null) {
        contents[_PMW] = __expectString(output[_PMW]);
    }
    if (output[_PMV] != null) {
        contents[_PMV] = de_PendingModifiedValues(output[_PMV], context);
    }
    if (output[_NC] != null) {
        contents[_NC] = de_NotificationConfiguration(output[_NC], context);
    }
    if (output.CacheSecurityGroups === "") {
        contents[_CSGa] = [];
    }
    else if (output[_CSGa] != null && output[_CSGa][_CSG] != null) {
        contents[_CSGa] = de_CacheSecurityGroupMembershipList(__getArrayIfSingleItem(output[_CSGa][_CSG]), context);
    }
    if (output[_CPG] != null) {
        contents[_CPG] = de_CacheParameterGroupStatus(output[_CPG], context);
    }
    if (output[_CSGNa] != null) {
        contents[_CSGNa] = __expectString(output[_CSGNa]);
    }
    if (output.CacheNodes === "") {
        contents[_CN] = [];
    }
    else if (output[_CN] != null && output[_CN][_CNa] != null) {
        contents[_CN] = de_CacheNodeList(__getArrayIfSingleItem(output[_CN][_CNa]), context);
    }
    if (output[_AMVU] != null) {
        contents[_AMVU] = __parseBoolean(output[_AMVU]);
    }
    if (output.SecurityGroups === "") {
        contents[_SG] = [];
    }
    else if (output[_SG] != null && output[_SG][_m] != null) {
        contents[_SG] = de_SecurityGroupMembershipList(__getArrayIfSingleItem(output[_SG][_m]), context);
    }
    if (output[_RGIe] != null) {
        contents[_RGIe] = __expectString(output[_RGIe]);
    }
    if (output[_SRL] != null) {
        contents[_SRL] = __strictParseInt32(output[_SRL]);
    }
    if (output[_SW] != null) {
        contents[_SW] = __expectString(output[_SW]);
    }
    if (output[_ATE] != null) {
        contents[_ATE] = __parseBoolean(output[_ATE]);
    }
    if (output[_ATLMD] != null) {
        contents[_ATLMD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_ATLMD]));
    }
    if (output[_TEE] != null) {
        contents[_TEE] = __parseBoolean(output[_TEE]);
    }
    if (output[_AREE] != null) {
        contents[_AREE] = __parseBoolean(output[_AREE]);
    }
    if (output[_ARN] != null) {
        contents[_ARN] = __expectString(output[_ARN]);
    }
    if (output[_RGLDE] != null) {
        contents[_RGLDE] = __parseBoolean(output[_RGLDE]);
    }
    if (output.LogDeliveryConfigurations === "") {
        contents[_LDC] = [];
    }
    else if (output[_LDC] != null && output[_LDC][_LDCo] != null) {
        contents[_LDC] = de_LogDeliveryConfigurationList(__getArrayIfSingleItem(output[_LDC][_LDCo]), context);
    }
    if (output[_NT] != null) {
        contents[_NT] = __expectString(output[_NT]);
    }
    if (output[_ID] != null) {
        contents[_ID] = __expectString(output[_ID]);
    }
    if (output[_TEM] != null) {
        contents[_TEM] = __expectString(output[_TEM]);
    }
    return contents;
};
const de_CacheClusterAlreadyExistsFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_CacheClusterList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CacheCluster(entry, context);
    });
};
const de_CacheClusterMessage = (output, context) => {
    const contents = {};
    if (output[_Ma] != null) {
        contents[_Ma] = __expectString(output[_Ma]);
    }
    if (output.CacheClusters === "") {
        contents[_CC] = [];
    }
    else if (output[_CC] != null && output[_CC][_CCa] != null) {
        contents[_CC] = de_CacheClusterList(__getArrayIfSingleItem(output[_CC][_CCa]), context);
    }
    return contents;
};
const de_CacheClusterNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_CacheEngineVersion = (output, context) => {
    const contents = {};
    if (output[_E] != null) {
        contents[_E] = __expectString(output[_E]);
    }
    if (output[_EV] != null) {
        contents[_EV] = __expectString(output[_EV]);
    }
    if (output[_CPGF] != null) {
        contents[_CPGF] = __expectString(output[_CPGF]);
    }
    if (output[_CED] != null) {
        contents[_CED] = __expectString(output[_CED]);
    }
    if (output[_CEVD] != null) {
        contents[_CEVD] = __expectString(output[_CEVD]);
    }
    return contents;
};
const de_CacheEngineVersionList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CacheEngineVersion(entry, context);
    });
};
const de_CacheEngineVersionMessage = (output, context) => {
    const contents = {};
    if (output[_Ma] != null) {
        contents[_Ma] = __expectString(output[_Ma]);
    }
    if (output.CacheEngineVersions === "") {
        contents[_CEV] = [];
    }
    else if (output[_CEV] != null && output[_CEV][_CEVa] != null) {
        contents[_CEV] = de_CacheEngineVersionList(__getArrayIfSingleItem(output[_CEV][_CEVa]), context);
    }
    return contents;
};
const de_CacheNode = (output, context) => {
    const contents = {};
    if (output[_CNI] != null) {
        contents[_CNI] = __expectString(output[_CNI]);
    }
    if (output[_CNS] != null) {
        contents[_CNS] = __expectString(output[_CNS]);
    }
    if (output[_CNCT] != null) {
        contents[_CNCT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_CNCT]));
    }
    if (output[_End] != null) {
        contents[_End] = de_Endpoint(output[_End], context);
    }
    if (output[_PGS] != null) {
        contents[_PGS] = __expectString(output[_PGS]);
    }
    if (output[_SCNIo] != null) {
        contents[_SCNIo] = __expectString(output[_SCNIo]);
    }
    if (output[_CAZ] != null) {
        contents[_CAZ] = __expectString(output[_CAZ]);
    }
    if (output[_COA] != null) {
        contents[_COA] = __expectString(output[_COA]);
    }
    return contents;
};
const de_CacheNodeIdsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_CacheNodeList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CacheNode(entry, context);
    });
};
const de_CacheNodeTypeSpecificParameter = (output, context) => {
    const contents = {};
    if (output[_PN] != null) {
        contents[_PN] = __expectString(output[_PN]);
    }
    if (output[_D] != null) {
        contents[_D] = __expectString(output[_D]);
    }
    if (output[_S] != null) {
        contents[_S] = __expectString(output[_S]);
    }
    if (output[_DTa] != null) {
        contents[_DTa] = __expectString(output[_DTa]);
    }
    if (output[_AV] != null) {
        contents[_AV] = __expectString(output[_AV]);
    }
    if (output[_IM] != null) {
        contents[_IM] = __parseBoolean(output[_IM]);
    }
    if (output[_MEVi] != null) {
        contents[_MEVi] = __expectString(output[_MEVi]);
    }
    if (output.CacheNodeTypeSpecificValues === "") {
        contents[_CNTSV] = [];
    }
    else if (output[_CNTSV] != null && output[_CNTSV][_CNTSVa] != null) {
        contents[_CNTSV] = de_CacheNodeTypeSpecificValueList(__getArrayIfSingleItem(output[_CNTSV][_CNTSVa]), context);
    }
    if (output[_CT] != null) {
        contents[_CT] = __expectString(output[_CT]);
    }
    return contents;
};
const de_CacheNodeTypeSpecificParametersList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CacheNodeTypeSpecificParameter(entry, context);
    });
};
const de_CacheNodeTypeSpecificValue = (output, context) => {
    const contents = {};
    if (output[_CNT] != null) {
        contents[_CNT] = __expectString(output[_CNT]);
    }
    if (output[_Val] != null) {
        contents[_Val] = __expectString(output[_Val]);
    }
    return contents;
};
const de_CacheNodeTypeSpecificValueList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CacheNodeTypeSpecificValue(entry, context);
    });
};
const de_CacheNodeUpdateStatus = (output, context) => {
    const contents = {};
    if (output[_CNI] != null) {
        contents[_CNI] = __expectString(output[_CNI]);
    }
    if (output[_NUS] != null) {
        contents[_NUS] = __expectString(output[_NUS]);
    }
    if (output[_NDD] != null) {
        contents[_NDD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_NDD]));
    }
    if (output[_NUSD] != null) {
        contents[_NUSD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_NUSD]));
    }
    if (output[_NUED] != null) {
        contents[_NUED] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_NUED]));
    }
    if (output[_NUIB] != null) {
        contents[_NUIB] = __expectString(output[_NUIB]);
    }
    if (output[_NUID] != null) {
        contents[_NUID] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_NUID]));
    }
    if (output[_NUSMD] != null) {
        contents[_NUSMD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_NUSMD]));
    }
    return contents;
};
const de_CacheNodeUpdateStatusList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CacheNodeUpdateStatus(entry, context);
    });
};
const de_CacheParameterGroup = (output, context) => {
    const contents = {};
    if (output[_CPGN] != null) {
        contents[_CPGN] = __expectString(output[_CPGN]);
    }
    if (output[_CPGF] != null) {
        contents[_CPGF] = __expectString(output[_CPGF]);
    }
    if (output[_D] != null) {
        contents[_D] = __expectString(output[_D]);
    }
    if (output[_IG] != null) {
        contents[_IG] = __parseBoolean(output[_IG]);
    }
    if (output[_ARN] != null) {
        contents[_ARN] = __expectString(output[_ARN]);
    }
    return contents;
};
const de_CacheParameterGroupAlreadyExistsFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_CacheParameterGroupDetails = (output, context) => {
    const contents = {};
    if (output[_Ma] != null) {
        contents[_Ma] = __expectString(output[_Ma]);
    }
    if (output.Parameters === "") {
        contents[_Pa] = [];
    }
    else if (output[_Pa] != null && output[_Pa][_Par] != null) {
        contents[_Pa] = de_ParametersList(__getArrayIfSingleItem(output[_Pa][_Par]), context);
    }
    if (output.CacheNodeTypeSpecificParameters === "") {
        contents[_CNTSP] = [];
    }
    else if (output[_CNTSP] != null && output[_CNTSP][_CNTSPa] != null) {
        contents[_CNTSP] = de_CacheNodeTypeSpecificParametersList(__getArrayIfSingleItem(output[_CNTSP][_CNTSPa]), context);
    }
    return contents;
};
const de_CacheParameterGroupList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CacheParameterGroup(entry, context);
    });
};
const de_CacheParameterGroupNameMessage = (output, context) => {
    const contents = {};
    if (output[_CPGN] != null) {
        contents[_CPGN] = __expectString(output[_CPGN]);
    }
    return contents;
};
const de_CacheParameterGroupNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_CacheParameterGroupQuotaExceededFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_CacheParameterGroupsMessage = (output, context) => {
    const contents = {};
    if (output[_Ma] != null) {
        contents[_Ma] = __expectString(output[_Ma]);
    }
    if (output.CacheParameterGroups === "") {
        contents[_CPGa] = [];
    }
    else if (output[_CPGa] != null && output[_CPGa][_CPG] != null) {
        contents[_CPGa] = de_CacheParameterGroupList(__getArrayIfSingleItem(output[_CPGa][_CPG]), context);
    }
    return contents;
};
const de_CacheParameterGroupStatus = (output, context) => {
    const contents = {};
    if (output[_CPGN] != null) {
        contents[_CPGN] = __expectString(output[_CPGN]);
    }
    if (output[_PAS] != null) {
        contents[_PAS] = __expectString(output[_PAS]);
    }
    if (output.CacheNodeIdsToReboot === "") {
        contents[_CNITRa] = [];
    }
    else if (output[_CNITRa] != null && output[_CNITRa][_CNI] != null) {
        contents[_CNITRa] = de_CacheNodeIdsList(__getArrayIfSingleItem(output[_CNITRa][_CNI]), context);
    }
    return contents;
};
const de_CacheSecurityGroup = (output, context) => {
    const contents = {};
    if (output[_OI] != null) {
        contents[_OI] = __expectString(output[_OI]);
    }
    if (output[_CSGN] != null) {
        contents[_CSGN] = __expectString(output[_CSGN]);
    }
    if (output[_D] != null) {
        contents[_D] = __expectString(output[_D]);
    }
    if (output.EC2SecurityGroups === "") {
        contents[_ECSG] = [];
    }
    else if (output[_ECSG] != null && output[_ECSG][_ECSGe] != null) {
        contents[_ECSG] = de_EC2SecurityGroupList(__getArrayIfSingleItem(output[_ECSG][_ECSGe]), context);
    }
    if (output[_ARN] != null) {
        contents[_ARN] = __expectString(output[_ARN]);
    }
    return contents;
};
const de_CacheSecurityGroupAlreadyExistsFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_CacheSecurityGroupMembership = (output, context) => {
    const contents = {};
    if (output[_CSGN] != null) {
        contents[_CSGN] = __expectString(output[_CSGN]);
    }
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    return contents;
};
const de_CacheSecurityGroupMembershipList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CacheSecurityGroupMembership(entry, context);
    });
};
const de_CacheSecurityGroupMessage = (output, context) => {
    const contents = {};
    if (output[_Ma] != null) {
        contents[_Ma] = __expectString(output[_Ma]);
    }
    if (output.CacheSecurityGroups === "") {
        contents[_CSGa] = [];
    }
    else if (output[_CSGa] != null && output[_CSGa][_CSG] != null) {
        contents[_CSGa] = de_CacheSecurityGroups(__getArrayIfSingleItem(output[_CSGa][_CSG]), context);
    }
    return contents;
};
const de_CacheSecurityGroupNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_CacheSecurityGroupQuotaExceededFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_CacheSecurityGroups = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CacheSecurityGroup(entry, context);
    });
};
const de_CacheSubnetGroup = (output, context) => {
    const contents = {};
    if (output[_CSGNa] != null) {
        contents[_CSGNa] = __expectString(output[_CSGNa]);
    }
    if (output[_CSGD] != null) {
        contents[_CSGD] = __expectString(output[_CSGD]);
    }
    if (output[_VI] != null) {
        contents[_VI] = __expectString(output[_VI]);
    }
    if (output.Subnets === "") {
        contents[_Su] = [];
    }
    else if (output[_Su] != null && output[_Su][_Sub] != null) {
        contents[_Su] = de_SubnetList(__getArrayIfSingleItem(output[_Su][_Sub]), context);
    }
    if (output[_ARN] != null) {
        contents[_ARN] = __expectString(output[_ARN]);
    }
    if (output.SupportedNetworkTypes === "") {
        contents[_SNT] = [];
    }
    else if (output[_SNT] != null && output[_SNT][_m] != null) {
        contents[_SNT] = de_NetworkTypeList(__getArrayIfSingleItem(output[_SNT][_m]), context);
    }
    return contents;
};
const de_CacheSubnetGroupAlreadyExistsFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_CacheSubnetGroupInUse = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_CacheSubnetGroupMessage = (output, context) => {
    const contents = {};
    if (output[_Ma] != null) {
        contents[_Ma] = __expectString(output[_Ma]);
    }
    if (output.CacheSubnetGroups === "") {
        contents[_CSGac] = [];
    }
    else if (output[_CSGac] != null && output[_CSGac][_CSGach] != null) {
        contents[_CSGac] = de_CacheSubnetGroups(__getArrayIfSingleItem(output[_CSGac][_CSGach]), context);
    }
    return contents;
};
const de_CacheSubnetGroupNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_CacheSubnetGroupQuotaExceededFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_CacheSubnetGroups = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CacheSubnetGroup(entry, context);
    });
};
const de_CacheSubnetQuotaExceededFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_CacheUsageLimits = (output, context) => {
    const contents = {};
    if (output[_DSa] != null) {
        contents[_DSa] = de_DataStorage(output[_DSa], context);
    }
    if (output[_ECPUPS] != null) {
        contents[_ECPUPS] = de_ECPUPerSecond(output[_ECPUPS], context);
    }
    return contents;
};
const de_CloudWatchLogsDestinationDetails = (output, context) => {
    const contents = {};
    if (output[_LG] != null) {
        contents[_LG] = __expectString(output[_LG]);
    }
    return contents;
};
const de_ClusterIdList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_ClusterQuotaForCustomerExceededFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_CompleteMigrationResponse = (output, context) => {
    const contents = {};
    if (output[_RG] != null) {
        contents[_RG] = de_ReplicationGroup(output[_RG], context);
    }
    return contents;
};
const de_CopyServerlessCacheSnapshotResponse = (output, context) => {
    const contents = {};
    if (output[_SCS] != null) {
        contents[_SCS] = de_ServerlessCacheSnapshot(output[_SCS], context);
    }
    return contents;
};
const de_CopySnapshotResult = (output, context) => {
    const contents = {};
    if (output[_Sn] != null) {
        contents[_Sn] = de_Snapshot(output[_Sn], context);
    }
    return contents;
};
const de_CreateCacheClusterResult = (output, context) => {
    const contents = {};
    if (output[_CCa] != null) {
        contents[_CCa] = de_CacheCluster(output[_CCa], context);
    }
    return contents;
};
const de_CreateCacheParameterGroupResult = (output, context) => {
    const contents = {};
    if (output[_CPG] != null) {
        contents[_CPG] = de_CacheParameterGroup(output[_CPG], context);
    }
    return contents;
};
const de_CreateCacheSecurityGroupResult = (output, context) => {
    const contents = {};
    if (output[_CSG] != null) {
        contents[_CSG] = de_CacheSecurityGroup(output[_CSG], context);
    }
    return contents;
};
const de_CreateCacheSubnetGroupResult = (output, context) => {
    const contents = {};
    if (output[_CSGach] != null) {
        contents[_CSGach] = de_CacheSubnetGroup(output[_CSGach], context);
    }
    return contents;
};
const de_CreateGlobalReplicationGroupResult = (output, context) => {
    const contents = {};
    if (output[_GRG] != null) {
        contents[_GRG] = de_GlobalReplicationGroup(output[_GRG], context);
    }
    return contents;
};
const de_CreateReplicationGroupResult = (output, context) => {
    const contents = {};
    if (output[_RG] != null) {
        contents[_RG] = de_ReplicationGroup(output[_RG], context);
    }
    return contents;
};
const de_CreateServerlessCacheResponse = (output, context) => {
    const contents = {};
    if (output[_SC] != null) {
        contents[_SC] = de_ServerlessCache(output[_SC], context);
    }
    return contents;
};
const de_CreateServerlessCacheSnapshotResponse = (output, context) => {
    const contents = {};
    if (output[_SCS] != null) {
        contents[_SCS] = de_ServerlessCacheSnapshot(output[_SCS], context);
    }
    return contents;
};
const de_CreateSnapshotResult = (output, context) => {
    const contents = {};
    if (output[_Sn] != null) {
        contents[_Sn] = de_Snapshot(output[_Sn], context);
    }
    return contents;
};
const de_DataStorage = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = __strictParseInt32(output[_M]);
    }
    if (output[_Mi] != null) {
        contents[_Mi] = __strictParseInt32(output[_Mi]);
    }
    if (output[_U] != null) {
        contents[_U] = __expectString(output[_U]);
    }
    return contents;
};
const de_DecreaseNodeGroupsInGlobalReplicationGroupResult = (output, context) => {
    const contents = {};
    if (output[_GRG] != null) {
        contents[_GRG] = de_GlobalReplicationGroup(output[_GRG], context);
    }
    return contents;
};
const de_DecreaseReplicaCountResult = (output, context) => {
    const contents = {};
    if (output[_RG] != null) {
        contents[_RG] = de_ReplicationGroup(output[_RG], context);
    }
    return contents;
};
const de_DefaultUserAssociatedToUserGroupFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_DefaultUserRequired = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_DeleteCacheClusterResult = (output, context) => {
    const contents = {};
    if (output[_CCa] != null) {
        contents[_CCa] = de_CacheCluster(output[_CCa], context);
    }
    return contents;
};
const de_DeleteGlobalReplicationGroupResult = (output, context) => {
    const contents = {};
    if (output[_GRG] != null) {
        contents[_GRG] = de_GlobalReplicationGroup(output[_GRG], context);
    }
    return contents;
};
const de_DeleteReplicationGroupResult = (output, context) => {
    const contents = {};
    if (output[_RG] != null) {
        contents[_RG] = de_ReplicationGroup(output[_RG], context);
    }
    return contents;
};
const de_DeleteServerlessCacheResponse = (output, context) => {
    const contents = {};
    if (output[_SC] != null) {
        contents[_SC] = de_ServerlessCache(output[_SC], context);
    }
    return contents;
};
const de_DeleteServerlessCacheSnapshotResponse = (output, context) => {
    const contents = {};
    if (output[_SCS] != null) {
        contents[_SCS] = de_ServerlessCacheSnapshot(output[_SCS], context);
    }
    return contents;
};
const de_DeleteSnapshotResult = (output, context) => {
    const contents = {};
    if (output[_Sn] != null) {
        contents[_Sn] = de_Snapshot(output[_Sn], context);
    }
    return contents;
};
const de_DescribeEngineDefaultParametersResult = (output, context) => {
    const contents = {};
    if (output[_ED] != null) {
        contents[_ED] = de_EngineDefaults(output[_ED], context);
    }
    return contents;
};
const de_DescribeGlobalReplicationGroupsResult = (output, context) => {
    const contents = {};
    if (output[_Ma] != null) {
        contents[_Ma] = __expectString(output[_Ma]);
    }
    if (output.GlobalReplicationGroups === "") {
        contents[_GRGl] = [];
    }
    else if (output[_GRGl] != null && output[_GRGl][_GRG] != null) {
        contents[_GRGl] = de_GlobalReplicationGroupList(__getArrayIfSingleItem(output[_GRGl][_GRG]), context);
    }
    return contents;
};
const de_DescribeServerlessCacheSnapshotsResponse = (output, context) => {
    const contents = {};
    if (output[_NTe] != null) {
        contents[_NTe] = __expectString(output[_NTe]);
    }
    if (output.ServerlessCacheSnapshots === "") {
        contents[_SCSe] = [];
    }
    else if (output[_SCSe] != null && output[_SCSe][_SCS] != null) {
        contents[_SCSe] = de_ServerlessCacheSnapshotList(__getArrayIfSingleItem(output[_SCSe][_SCS]), context);
    }
    return contents;
};
const de_DescribeServerlessCachesResponse = (output, context) => {
    const contents = {};
    if (output[_NTe] != null) {
        contents[_NTe] = __expectString(output[_NTe]);
    }
    if (output.ServerlessCaches === "") {
        contents[_SCe] = [];
    }
    else if (output[_SCe] != null && output[_SCe][_m] != null) {
        contents[_SCe] = de_ServerlessCacheList(__getArrayIfSingleItem(output[_SCe][_m]), context);
    }
    return contents;
};
const de_DescribeSnapshotsListMessage = (output, context) => {
    const contents = {};
    if (output[_Ma] != null) {
        contents[_Ma] = __expectString(output[_Ma]);
    }
    if (output.Snapshots === "") {
        contents[_Sna] = [];
    }
    else if (output[_Sna] != null && output[_Sna][_Sn] != null) {
        contents[_Sna] = de_SnapshotList(__getArrayIfSingleItem(output[_Sna][_Sn]), context);
    }
    return contents;
};
const de_DescribeUserGroupsResult = (output, context) => {
    const contents = {};
    if (output.UserGroups === "") {
        contents[_UG] = [];
    }
    else if (output[_UG] != null && output[_UG][_m] != null) {
        contents[_UG] = de_UserGroupList(__getArrayIfSingleItem(output[_UG][_m]), context);
    }
    if (output[_Ma] != null) {
        contents[_Ma] = __expectString(output[_Ma]);
    }
    return contents;
};
const de_DescribeUsersResult = (output, context) => {
    const contents = {};
    if (output.Users === "") {
        contents[_Us] = [];
    }
    else if (output[_Us] != null && output[_Us][_m] != null) {
        contents[_Us] = de_UserList(__getArrayIfSingleItem(output[_Us][_m]), context);
    }
    if (output[_Ma] != null) {
        contents[_Ma] = __expectString(output[_Ma]);
    }
    return contents;
};
const de_DestinationDetails = (output, context) => {
    const contents = {};
    if (output[_CWLD] != null) {
        contents[_CWLD] = de_CloudWatchLogsDestinationDetails(output[_CWLD], context);
    }
    if (output[_KFD] != null) {
        contents[_KFD] = de_KinesisFirehoseDestinationDetails(output[_KFD], context);
    }
    return contents;
};
const de_DisassociateGlobalReplicationGroupResult = (output, context) => {
    const contents = {};
    if (output[_GRG] != null) {
        contents[_GRG] = de_GlobalReplicationGroup(output[_GRG], context);
    }
    return contents;
};
const de_DuplicateUserNameFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_EC2SecurityGroup = (output, context) => {
    const contents = {};
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    if (output[_ECSGN] != null) {
        contents[_ECSGN] = __expectString(output[_ECSGN]);
    }
    if (output[_ECSGOI] != null) {
        contents[_ECSGOI] = __expectString(output[_ECSGOI]);
    }
    return contents;
};
const de_EC2SecurityGroupList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_EC2SecurityGroup(entry, context);
    });
};
const de_ECPUPerSecond = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = __strictParseInt32(output[_M]);
    }
    if (output[_Mi] != null) {
        contents[_Mi] = __strictParseInt32(output[_Mi]);
    }
    return contents;
};
const de_Endpoint = (output, context) => {
    const contents = {};
    if (output[_Ad] != null) {
        contents[_Ad] = __expectString(output[_Ad]);
    }
    if (output[_Po] != null) {
        contents[_Po] = __strictParseInt32(output[_Po]);
    }
    return contents;
};
const de_EngineDefaults = (output, context) => {
    const contents = {};
    if (output[_CPGF] != null) {
        contents[_CPGF] = __expectString(output[_CPGF]);
    }
    if (output[_Ma] != null) {
        contents[_Ma] = __expectString(output[_Ma]);
    }
    if (output.Parameters === "") {
        contents[_Pa] = [];
    }
    else if (output[_Pa] != null && output[_Pa][_Par] != null) {
        contents[_Pa] = de_ParametersList(__getArrayIfSingleItem(output[_Pa][_Par]), context);
    }
    if (output.CacheNodeTypeSpecificParameters === "") {
        contents[_CNTSP] = [];
    }
    else if (output[_CNTSP] != null && output[_CNTSP][_CNTSPa] != null) {
        contents[_CNTSP] = de_CacheNodeTypeSpecificParametersList(__getArrayIfSingleItem(output[_CNTSP][_CNTSPa]), context);
    }
    return contents;
};
const de_Event = (output, context) => {
    const contents = {};
    if (output[_SIo] != null) {
        contents[_SIo] = __expectString(output[_SIo]);
    }
    if (output[_ST] != null) {
        contents[_ST] = __expectString(output[_ST]);
    }
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    if (output[_Da] != null) {
        contents[_Da] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_Da]));
    }
    return contents;
};
const de_EventList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Event(entry, context);
    });
};
const de_EventsMessage = (output, context) => {
    const contents = {};
    if (output[_Ma] != null) {
        contents[_Ma] = __expectString(output[_Ma]);
    }
    if (output.Events === "") {
        contents[_Ev] = [];
    }
    else if (output[_Ev] != null && output[_Ev][_Eve] != null) {
        contents[_Ev] = de_EventList(__getArrayIfSingleItem(output[_Ev][_Eve]), context);
    }
    return contents;
};
const de_ExportServerlessCacheSnapshotResponse = (output, context) => {
    const contents = {};
    if (output[_SCS] != null) {
        contents[_SCS] = de_ServerlessCacheSnapshot(output[_SCS], context);
    }
    return contents;
};
const de_FailoverGlobalReplicationGroupResult = (output, context) => {
    const contents = {};
    if (output[_GRG] != null) {
        contents[_GRG] = de_GlobalReplicationGroup(output[_GRG], context);
    }
    return contents;
};
const de_GlobalNodeGroup = (output, context) => {
    const contents = {};
    if (output[_GNGI] != null) {
        contents[_GNGI] = __expectString(output[_GNGI]);
    }
    if (output[_Sl] != null) {
        contents[_Sl] = __expectString(output[_Sl]);
    }
    return contents;
};
const de_GlobalNodeGroupList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_GlobalNodeGroup(entry, context);
    });
};
const de_GlobalReplicationGroup = (output, context) => {
    const contents = {};
    if (output[_GRGI] != null) {
        contents[_GRGI] = __expectString(output[_GRGI]);
    }
    if (output[_GRGD] != null) {
        contents[_GRGD] = __expectString(output[_GRGD]);
    }
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    if (output[_CNT] != null) {
        contents[_CNT] = __expectString(output[_CNT]);
    }
    if (output[_E] != null) {
        contents[_E] = __expectString(output[_E]);
    }
    if (output[_EV] != null) {
        contents[_EV] = __expectString(output[_EV]);
    }
    if (output.Members === "") {
        contents[_Mem] = [];
    }
    else if (output[_Mem] != null && output[_Mem][_GRGM] != null) {
        contents[_Mem] = de_GlobalReplicationGroupMemberList(__getArrayIfSingleItem(output[_Mem][_GRGM]), context);
    }
    if (output[_CEl] != null) {
        contents[_CEl] = __parseBoolean(output[_CEl]);
    }
    if (output.GlobalNodeGroups === "") {
        contents[_GNG] = [];
    }
    else if (output[_GNG] != null && output[_GNG][_GNGl] != null) {
        contents[_GNG] = de_GlobalNodeGroupList(__getArrayIfSingleItem(output[_GNG][_GNGl]), context);
    }
    if (output[_ATE] != null) {
        contents[_ATE] = __parseBoolean(output[_ATE]);
    }
    if (output[_TEE] != null) {
        contents[_TEE] = __parseBoolean(output[_TEE]);
    }
    if (output[_AREE] != null) {
        contents[_AREE] = __parseBoolean(output[_AREE]);
    }
    if (output[_ARN] != null) {
        contents[_ARN] = __expectString(output[_ARN]);
    }
    return contents;
};
const de_GlobalReplicationGroupAlreadyExistsFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_GlobalReplicationGroupInfo = (output, context) => {
    const contents = {};
    if (output[_GRGI] != null) {
        contents[_GRGI] = __expectString(output[_GRGI]);
    }
    if (output[_GRGMR] != null) {
        contents[_GRGMR] = __expectString(output[_GRGMR]);
    }
    return contents;
};
const de_GlobalReplicationGroupList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_GlobalReplicationGroup(entry, context);
    });
};
const de_GlobalReplicationGroupMember = (output, context) => {
    const contents = {};
    if (output[_RGIe] != null) {
        contents[_RGIe] = __expectString(output[_RGIe]);
    }
    if (output[_RGR] != null) {
        contents[_RGR] = __expectString(output[_RGR]);
    }
    if (output[_R] != null) {
        contents[_R] = __expectString(output[_R]);
    }
    if (output[_AF] != null) {
        contents[_AF] = __expectString(output[_AF]);
    }
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    return contents;
};
const de_GlobalReplicationGroupMemberList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_GlobalReplicationGroupMember(entry, context);
    });
};
const de_GlobalReplicationGroupNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_IncreaseNodeGroupsInGlobalReplicationGroupResult = (output, context) => {
    const contents = {};
    if (output[_GRG] != null) {
        contents[_GRG] = de_GlobalReplicationGroup(output[_GRG], context);
    }
    return contents;
};
const de_IncreaseReplicaCountResult = (output, context) => {
    const contents = {};
    if (output[_RG] != null) {
        contents[_RG] = de_ReplicationGroup(output[_RG], context);
    }
    return contents;
};
const de_InsufficientCacheClusterCapacityFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_InvalidARNFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_InvalidCacheClusterStateFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_InvalidCacheParameterGroupStateFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_InvalidCacheSecurityGroupStateFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_InvalidCredentialsException = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_InvalidGlobalReplicationGroupStateFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_InvalidKMSKeyFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_InvalidParameterCombinationException = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_InvalidParameterValueException = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_InvalidReplicationGroupStateFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_InvalidServerlessCacheSnapshotStateFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_InvalidServerlessCacheStateFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_InvalidSnapshotStateFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_InvalidSubnet = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_InvalidUserGroupStateFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_InvalidUserStateFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_InvalidVPCNetworkStateFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_KinesisFirehoseDestinationDetails = (output, context) => {
    const contents = {};
    if (output[_DSel] != null) {
        contents[_DSel] = __expectString(output[_DSel]);
    }
    return contents;
};
const de_LogDeliveryConfiguration = (output, context) => {
    const contents = {};
    if (output[_LT] != null) {
        contents[_LT] = __expectString(output[_LT]);
    }
    if (output[_DT] != null) {
        contents[_DT] = __expectString(output[_DT]);
    }
    if (output[_DD] != null) {
        contents[_DD] = de_DestinationDetails(output[_DD], context);
    }
    if (output[_LF] != null) {
        contents[_LF] = __expectString(output[_LF]);
    }
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_LogDeliveryConfigurationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LogDeliveryConfiguration(entry, context);
    });
};
const de_ModifyCacheClusterResult = (output, context) => {
    const contents = {};
    if (output[_CCa] != null) {
        contents[_CCa] = de_CacheCluster(output[_CCa], context);
    }
    return contents;
};
const de_ModifyCacheSubnetGroupResult = (output, context) => {
    const contents = {};
    if (output[_CSGach] != null) {
        contents[_CSGach] = de_CacheSubnetGroup(output[_CSGach], context);
    }
    return contents;
};
const de_ModifyGlobalReplicationGroupResult = (output, context) => {
    const contents = {};
    if (output[_GRG] != null) {
        contents[_GRG] = de_GlobalReplicationGroup(output[_GRG], context);
    }
    return contents;
};
const de_ModifyReplicationGroupResult = (output, context) => {
    const contents = {};
    if (output[_RG] != null) {
        contents[_RG] = de_ReplicationGroup(output[_RG], context);
    }
    return contents;
};
const de_ModifyReplicationGroupShardConfigurationResult = (output, context) => {
    const contents = {};
    if (output[_RG] != null) {
        contents[_RG] = de_ReplicationGroup(output[_RG], context);
    }
    return contents;
};
const de_ModifyServerlessCacheResponse = (output, context) => {
    const contents = {};
    if (output[_SC] != null) {
        contents[_SC] = de_ServerlessCache(output[_SC], context);
    }
    return contents;
};
const de_NetworkTypeList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_NodeGroup = (output, context) => {
    const contents = {};
    if (output[_NGI] != null) {
        contents[_NGI] = __expectString(output[_NGI]);
    }
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    if (output[_PE] != null) {
        contents[_PE] = de_Endpoint(output[_PE], context);
    }
    if (output[_RE] != null) {
        contents[_RE] = de_Endpoint(output[_RE], context);
    }
    if (output[_Sl] != null) {
        contents[_Sl] = __expectString(output[_Sl]);
    }
    if (output.NodeGroupMembers === "") {
        contents[_NGM] = [];
    }
    else if (output[_NGM] != null && output[_NGM][_NGMo] != null) {
        contents[_NGM] = de_NodeGroupMemberList(__getArrayIfSingleItem(output[_NGM][_NGMo]), context);
    }
    return contents;
};
const de_NodeGroupConfiguration = (output, context) => {
    const contents = {};
    if (output[_NGI] != null) {
        contents[_NGI] = __expectString(output[_NGI]);
    }
    if (output[_Sl] != null) {
        contents[_Sl] = __expectString(output[_Sl]);
    }
    if (output[_RCep] != null) {
        contents[_RCep] = __strictParseInt32(output[_RCep]);
    }
    if (output[_PAZri] != null) {
        contents[_PAZri] = __expectString(output[_PAZri]);
    }
    if (output.ReplicaAvailabilityZones === "") {
        contents[_RAZ] = [];
    }
    else if (output[_RAZ] != null && output[_RAZ][_AZ] != null) {
        contents[_RAZ] = de_AvailabilityZonesList(__getArrayIfSingleItem(output[_RAZ][_AZ]), context);
    }
    if (output[_POAri] != null) {
        contents[_POAri] = __expectString(output[_POAri]);
    }
    if (output.ReplicaOutpostArns === "") {
        contents[_ROA] = [];
    }
    else if (output[_ROA] != null && output[_ROA][_OA] != null) {
        contents[_ROA] = de_OutpostArnsList(__getArrayIfSingleItem(output[_ROA][_OA]), context);
    }
    return contents;
};
const de_NodeGroupList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_NodeGroup(entry, context);
    });
};
const de_NodeGroupMember = (output, context) => {
    const contents = {};
    if (output[_CCIa] != null) {
        contents[_CCIa] = __expectString(output[_CCIa]);
    }
    if (output[_CNI] != null) {
        contents[_CNI] = __expectString(output[_CNI]);
    }
    if (output[_REe] != null) {
        contents[_REe] = de_Endpoint(output[_REe], context);
    }
    if (output[_PAZr] != null) {
        contents[_PAZr] = __expectString(output[_PAZr]);
    }
    if (output[_POAr] != null) {
        contents[_POAr] = __expectString(output[_POAr]);
    }
    if (output[_CR] != null) {
        contents[_CR] = __expectString(output[_CR]);
    }
    return contents;
};
const de_NodeGroupMemberList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_NodeGroupMember(entry, context);
    });
};
const de_NodeGroupMemberUpdateStatus = (output, context) => {
    const contents = {};
    if (output[_CCIa] != null) {
        contents[_CCIa] = __expectString(output[_CCIa]);
    }
    if (output[_CNI] != null) {
        contents[_CNI] = __expectString(output[_CNI]);
    }
    if (output[_NUS] != null) {
        contents[_NUS] = __expectString(output[_NUS]);
    }
    if (output[_NDD] != null) {
        contents[_NDD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_NDD]));
    }
    if (output[_NUSD] != null) {
        contents[_NUSD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_NUSD]));
    }
    if (output[_NUED] != null) {
        contents[_NUED] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_NUED]));
    }
    if (output[_NUIB] != null) {
        contents[_NUIB] = __expectString(output[_NUIB]);
    }
    if (output[_NUID] != null) {
        contents[_NUID] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_NUID]));
    }
    if (output[_NUSMD] != null) {
        contents[_NUSMD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_NUSMD]));
    }
    return contents;
};
const de_NodeGroupMemberUpdateStatusList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_NodeGroupMemberUpdateStatus(entry, context);
    });
};
const de_NodeGroupNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_NodeGroupsPerReplicationGroupQuotaExceededFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_NodeGroupUpdateStatus = (output, context) => {
    const contents = {};
    if (output[_NGI] != null) {
        contents[_NGI] = __expectString(output[_NGI]);
    }
    if (output.NodeGroupMemberUpdateStatus === "") {
        contents[_NGMUS] = [];
    }
    else if (output[_NGMUS] != null && output[_NGMUS][_NGMUS] != null) {
        contents[_NGMUS] = de_NodeGroupMemberUpdateStatusList(__getArrayIfSingleItem(output[_NGMUS][_NGMUS]), context);
    }
    return contents;
};
const de_NodeGroupUpdateStatusList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_NodeGroupUpdateStatus(entry, context);
    });
};
const de_NodeQuotaForClusterExceededFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_NodeQuotaForCustomerExceededFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_NodeSnapshot = (output, context) => {
    const contents = {};
    if (output[_CCIa] != null) {
        contents[_CCIa] = __expectString(output[_CCIa]);
    }
    if (output[_NGI] != null) {
        contents[_NGI] = __expectString(output[_NGI]);
    }
    if (output[_CNI] != null) {
        contents[_CNI] = __expectString(output[_CNI]);
    }
    if (output[_NGC] != null) {
        contents[_NGC] = de_NodeGroupConfiguration(output[_NGC], context);
    }
    if (output[_CSa] != null) {
        contents[_CSa] = __expectString(output[_CSa]);
    }
    if (output[_CNCT] != null) {
        contents[_CNCT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_CNCT]));
    }
    if (output[_SCT] != null) {
        contents[_SCT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_SCT]));
    }
    return contents;
};
const de_NodeSnapshotList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_NodeSnapshot(entry, context);
    });
};
const de_NodeTypeList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_NoOperationFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_NotificationConfiguration = (output, context) => {
    const contents = {};
    if (output[_TA] != null) {
        contents[_TA] = __expectString(output[_TA]);
    }
    if (output[_TS] != null) {
        contents[_TS] = __expectString(output[_TS]);
    }
    return contents;
};
const de_OutpostArnsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_Parameter = (output, context) => {
    const contents = {};
    if (output[_PN] != null) {
        contents[_PN] = __expectString(output[_PN]);
    }
    if (output[_PV] != null) {
        contents[_PV] = __expectString(output[_PV]);
    }
    if (output[_D] != null) {
        contents[_D] = __expectString(output[_D]);
    }
    if (output[_S] != null) {
        contents[_S] = __expectString(output[_S]);
    }
    if (output[_DTa] != null) {
        contents[_DTa] = __expectString(output[_DTa]);
    }
    if (output[_AV] != null) {
        contents[_AV] = __expectString(output[_AV]);
    }
    if (output[_IM] != null) {
        contents[_IM] = __parseBoolean(output[_IM]);
    }
    if (output[_MEVi] != null) {
        contents[_MEVi] = __expectString(output[_MEVi]);
    }
    if (output[_CT] != null) {
        contents[_CT] = __expectString(output[_CT]);
    }
    return contents;
};
const de_ParametersList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Parameter(entry, context);
    });
};
const de_PendingLogDeliveryConfiguration = (output, context) => {
    const contents = {};
    if (output[_LT] != null) {
        contents[_LT] = __expectString(output[_LT]);
    }
    if (output[_DT] != null) {
        contents[_DT] = __expectString(output[_DT]);
    }
    if (output[_DD] != null) {
        contents[_DD] = de_DestinationDetails(output[_DD], context);
    }
    if (output[_LF] != null) {
        contents[_LF] = __expectString(output[_LF]);
    }
    return contents;
};
const de_PendingLogDeliveryConfigurationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PendingLogDeliveryConfiguration(entry, context);
    });
};
const de_PendingModifiedValues = (output, context) => {
    const contents = {};
    if (output[_NCN] != null) {
        contents[_NCN] = __strictParseInt32(output[_NCN]);
    }
    if (output.CacheNodeIdsToRemove === "") {
        contents[_CNITR] = [];
    }
    else if (output[_CNITR] != null && output[_CNITR][_CNI] != null) {
        contents[_CNITR] = de_CacheNodeIdsList(__getArrayIfSingleItem(output[_CNITR][_CNI]), context);
    }
    if (output[_EV] != null) {
        contents[_EV] = __expectString(output[_EV]);
    }
    if (output[_CNT] != null) {
        contents[_CNT] = __expectString(output[_CNT]);
    }
    if (output[_ATS] != null) {
        contents[_ATS] = __expectString(output[_ATS]);
    }
    if (output.LogDeliveryConfigurations === "") {
        contents[_LDC] = [];
    }
    else if (output[_LDC] != null && output[_LDC][_m] != null) {
        contents[_LDC] = de_PendingLogDeliveryConfigurationList(__getArrayIfSingleItem(output[_LDC][_m]), context);
    }
    if (output[_TEE] != null) {
        contents[_TEE] = __parseBoolean(output[_TEE]);
    }
    if (output[_TEM] != null) {
        contents[_TEM] = __expectString(output[_TEM]);
    }
    return contents;
};
const de_ProcessedUpdateAction = (output, context) => {
    const contents = {};
    if (output[_RGIe] != null) {
        contents[_RGIe] = __expectString(output[_RGIe]);
    }
    if (output[_CCIa] != null) {
        contents[_CCIa] = __expectString(output[_CCIa]);
    }
    if (output[_SUN] != null) {
        contents[_SUN] = __expectString(output[_SUN]);
    }
    if (output[_UAS] != null) {
        contents[_UAS] = __expectString(output[_UAS]);
    }
    return contents;
};
const de_ProcessedUpdateActionList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ProcessedUpdateAction(entry, context);
    });
};
const de_PurchaseReservedCacheNodesOfferingResult = (output, context) => {
    const contents = {};
    if (output[_RCN] != null) {
        contents[_RCN] = de_ReservedCacheNode(output[_RCN], context);
    }
    return contents;
};
const de_RebalanceSlotsInGlobalReplicationGroupResult = (output, context) => {
    const contents = {};
    if (output[_GRG] != null) {
        contents[_GRG] = de_GlobalReplicationGroup(output[_GRG], context);
    }
    return contents;
};
const de_RebootCacheClusterResult = (output, context) => {
    const contents = {};
    if (output[_CCa] != null) {
        contents[_CCa] = de_CacheCluster(output[_CCa], context);
    }
    return contents;
};
const de_RecurringCharge = (output, context) => {
    const contents = {};
    if (output[_RCA] != null) {
        contents[_RCA] = __strictParseFloat(output[_RCA]);
    }
    if (output[_RCF] != null) {
        contents[_RCF] = __expectString(output[_RCF]);
    }
    return contents;
};
const de_RecurringChargeList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RecurringCharge(entry, context);
    });
};
const de_ReplicationGroup = (output, context) => {
    const contents = {};
    if (output[_RGIe] != null) {
        contents[_RGIe] = __expectString(output[_RGIe]);
    }
    if (output[_D] != null) {
        contents[_D] = __expectString(output[_D]);
    }
    if (output[_GRGIl] != null) {
        contents[_GRGIl] = de_GlobalReplicationGroupInfo(output[_GRGIl], context);
    }
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    if (output[_PMV] != null) {
        contents[_PMV] = de_ReplicationGroupPendingModifiedValues(output[_PMV], context);
    }
    if (output.MemberClusters === "") {
        contents[_MC] = [];
    }
    else if (output[_MC] != null && output[_MC][_CI] != null) {
        contents[_MC] = de_ClusterIdList(__getArrayIfSingleItem(output[_MC][_CI]), context);
    }
    if (output.NodeGroups === "") {
        contents[_NG] = [];
    }
    else if (output[_NG] != null && output[_NG][_NGo] != null) {
        contents[_NG] = de_NodeGroupList(__getArrayIfSingleItem(output[_NG][_NGo]), context);
    }
    if (output[_SCI] != null) {
        contents[_SCI] = __expectString(output[_SCI]);
    }
    if (output[_AF] != null) {
        contents[_AF] = __expectString(output[_AF]);
    }
    if (output[_MAZ] != null) {
        contents[_MAZ] = __expectString(output[_MAZ]);
    }
    if (output[_CE] != null) {
        contents[_CE] = de_Endpoint(output[_CE], context);
    }
    if (output[_SRL] != null) {
        contents[_SRL] = __strictParseInt32(output[_SRL]);
    }
    if (output[_SW] != null) {
        contents[_SW] = __expectString(output[_SW]);
    }
    if (output[_CEl] != null) {
        contents[_CEl] = __parseBoolean(output[_CEl]);
    }
    if (output[_CNT] != null) {
        contents[_CNT] = __expectString(output[_CNT]);
    }
    if (output[_ATE] != null) {
        contents[_ATE] = __parseBoolean(output[_ATE]);
    }
    if (output[_ATLMD] != null) {
        contents[_ATLMD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_ATLMD]));
    }
    if (output[_TEE] != null) {
        contents[_TEE] = __parseBoolean(output[_TEE]);
    }
    if (output[_AREE] != null) {
        contents[_AREE] = __parseBoolean(output[_AREE]);
    }
    if (output.MemberClustersOutpostArns === "") {
        contents[_MCOA] = [];
    }
    else if (output[_MCOA] != null && output[_MCOA][_RGOA] != null) {
        contents[_MCOA] = de_ReplicationGroupOutpostArnList(__getArrayIfSingleItem(output[_MCOA][_RGOA]), context);
    }
    if (output[_KKI] != null) {
        contents[_KKI] = __expectString(output[_KKI]);
    }
    if (output[_ARN] != null) {
        contents[_ARN] = __expectString(output[_ARN]);
    }
    if (output.UserGroupIds === "") {
        contents[_UGI] = [];
    }
    else if (output[_UGI] != null && output[_UGI][_m] != null) {
        contents[_UGI] = de_UserGroupIdList(__getArrayIfSingleItem(output[_UGI][_m]), context);
    }
    if (output.LogDeliveryConfigurations === "") {
        contents[_LDC] = [];
    }
    else if (output[_LDC] != null && output[_LDC][_LDCo] != null) {
        contents[_LDC] = de_LogDeliveryConfigurationList(__getArrayIfSingleItem(output[_LDC][_LDCo]), context);
    }
    if (output[_RGCT] != null) {
        contents[_RGCT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_RGCT]));
    }
    if (output[_DTat] != null) {
        contents[_DTat] = __expectString(output[_DTat]);
    }
    if (output[_AMVU] != null) {
        contents[_AMVU] = __parseBoolean(output[_AMVU]);
    }
    if (output[_NT] != null) {
        contents[_NT] = __expectString(output[_NT]);
    }
    if (output[_ID] != null) {
        contents[_ID] = __expectString(output[_ID]);
    }
    if (output[_TEM] != null) {
        contents[_TEM] = __expectString(output[_TEM]);
    }
    if (output[_CMl] != null) {
        contents[_CMl] = __expectString(output[_CMl]);
    }
    if (output[_E] != null) {
        contents[_E] = __expectString(output[_E]);
    }
    return contents;
};
const de_ReplicationGroupAlreadyExistsFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_ReplicationGroupAlreadyUnderMigrationFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_ReplicationGroupList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ReplicationGroup(entry, context);
    });
};
const de_ReplicationGroupMessage = (output, context) => {
    const contents = {};
    if (output[_Ma] != null) {
        contents[_Ma] = __expectString(output[_Ma]);
    }
    if (output.ReplicationGroups === "") {
        contents[_RGe] = [];
    }
    else if (output[_RGe] != null && output[_RGe][_RG] != null) {
        contents[_RGe] = de_ReplicationGroupList(__getArrayIfSingleItem(output[_RGe][_RG]), context);
    }
    return contents;
};
const de_ReplicationGroupNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_ReplicationGroupNotUnderMigrationFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_ReplicationGroupOutpostArnList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_ReplicationGroupPendingModifiedValues = (output, context) => {
    const contents = {};
    if (output[_PCI] != null) {
        contents[_PCI] = __expectString(output[_PCI]);
    }
    if (output[_AFS] != null) {
        contents[_AFS] = __expectString(output[_AFS]);
    }
    if (output[_Re] != null) {
        contents[_Re] = de_ReshardingStatus(output[_Re], context);
    }
    if (output[_ATS] != null) {
        contents[_ATS] = __expectString(output[_ATS]);
    }
    if (output[_UG] != null) {
        contents[_UG] = de_UserGroupsUpdateStatus(output[_UG], context);
    }
    if (output.LogDeliveryConfigurations === "") {
        contents[_LDC] = [];
    }
    else if (output[_LDC] != null && output[_LDC][_m] != null) {
        contents[_LDC] = de_PendingLogDeliveryConfigurationList(__getArrayIfSingleItem(output[_LDC][_m]), context);
    }
    if (output[_TEE] != null) {
        contents[_TEE] = __parseBoolean(output[_TEE]);
    }
    if (output[_TEM] != null) {
        contents[_TEM] = __expectString(output[_TEM]);
    }
    if (output[_CMl] != null) {
        contents[_CMl] = __expectString(output[_CMl]);
    }
    return contents;
};
const de_ReservedCacheNode = (output, context) => {
    const contents = {};
    if (output[_RCNI] != null) {
        contents[_RCNI] = __expectString(output[_RCNI]);
    }
    if (output[_RCNOI] != null) {
        contents[_RCNOI] = __expectString(output[_RCNOI]);
    }
    if (output[_CNT] != null) {
        contents[_CNT] = __expectString(output[_CNT]);
    }
    if (output[_STt] != null) {
        contents[_STt] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_STt]));
    }
    if (output[_Du] != null) {
        contents[_Du] = __strictParseInt32(output[_Du]);
    }
    if (output[_FP] != null) {
        contents[_FP] = __strictParseFloat(output[_FP]);
    }
    if (output[_UP] != null) {
        contents[_UP] = __strictParseFloat(output[_UP]);
    }
    if (output[_CNC] != null) {
        contents[_CNC] = __strictParseInt32(output[_CNC]);
    }
    if (output[_PD] != null) {
        contents[_PD] = __expectString(output[_PD]);
    }
    if (output[_OT] != null) {
        contents[_OT] = __expectString(output[_OT]);
    }
    if (output[_Sta] != null) {
        contents[_Sta] = __expectString(output[_Sta]);
    }
    if (output.RecurringCharges === "") {
        contents[_RCec] = [];
    }
    else if (output[_RCec] != null && output[_RCec][_RCecu] != null) {
        contents[_RCec] = de_RecurringChargeList(__getArrayIfSingleItem(output[_RCec][_RCecu]), context);
    }
    if (output[_RARN] != null) {
        contents[_RARN] = __expectString(output[_RARN]);
    }
    return contents;
};
const de_ReservedCacheNodeAlreadyExistsFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_ReservedCacheNodeList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ReservedCacheNode(entry, context);
    });
};
const de_ReservedCacheNodeMessage = (output, context) => {
    const contents = {};
    if (output[_Ma] != null) {
        contents[_Ma] = __expectString(output[_Ma]);
    }
    if (output.ReservedCacheNodes === "") {
        contents[_RCNe] = [];
    }
    else if (output[_RCNe] != null && output[_RCNe][_RCN] != null) {
        contents[_RCNe] = de_ReservedCacheNodeList(__getArrayIfSingleItem(output[_RCNe][_RCN]), context);
    }
    return contents;
};
const de_ReservedCacheNodeNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_ReservedCacheNodeQuotaExceededFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_ReservedCacheNodesOffering = (output, context) => {
    const contents = {};
    if (output[_RCNOI] != null) {
        contents[_RCNOI] = __expectString(output[_RCNOI]);
    }
    if (output[_CNT] != null) {
        contents[_CNT] = __expectString(output[_CNT]);
    }
    if (output[_Du] != null) {
        contents[_Du] = __strictParseInt32(output[_Du]);
    }
    if (output[_FP] != null) {
        contents[_FP] = __strictParseFloat(output[_FP]);
    }
    if (output[_UP] != null) {
        contents[_UP] = __strictParseFloat(output[_UP]);
    }
    if (output[_PD] != null) {
        contents[_PD] = __expectString(output[_PD]);
    }
    if (output[_OT] != null) {
        contents[_OT] = __expectString(output[_OT]);
    }
    if (output.RecurringCharges === "") {
        contents[_RCec] = [];
    }
    else if (output[_RCec] != null && output[_RCec][_RCecu] != null) {
        contents[_RCec] = de_RecurringChargeList(__getArrayIfSingleItem(output[_RCec][_RCecu]), context);
    }
    return contents;
};
const de_ReservedCacheNodesOfferingList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ReservedCacheNodesOffering(entry, context);
    });
};
const de_ReservedCacheNodesOfferingMessage = (output, context) => {
    const contents = {};
    if (output[_Ma] != null) {
        contents[_Ma] = __expectString(output[_Ma]);
    }
    if (output.ReservedCacheNodesOfferings === "") {
        contents[_RCNO] = [];
    }
    else if (output[_RCNO] != null && output[_RCNO][_RCNOe] != null) {
        contents[_RCNO] = de_ReservedCacheNodesOfferingList(__getArrayIfSingleItem(output[_RCNO][_RCNOe]), context);
    }
    return contents;
};
const de_ReservedCacheNodesOfferingNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_ReshardingStatus = (output, context) => {
    const contents = {};
    if (output[_SMl] != null) {
        contents[_SMl] = de_SlotMigration(output[_SMl], context);
    }
    return contents;
};
const de_RevokeCacheSecurityGroupIngressResult = (output, context) => {
    const contents = {};
    if (output[_CSG] != null) {
        contents[_CSG] = de_CacheSecurityGroup(output[_CSG], context);
    }
    return contents;
};
const de_SecurityGroupIdsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_SecurityGroupMembership = (output, context) => {
    const contents = {};
    if (output[_SGIe] != null) {
        contents[_SGIe] = __expectString(output[_SGIe]);
    }
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    return contents;
};
const de_SecurityGroupMembershipList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SecurityGroupMembership(entry, context);
    });
};
const de_ServerlessCache = (output, context) => {
    const contents = {};
    if (output[_SCN] != null) {
        contents[_SCN] = __expectString(output[_SCN]);
    }
    if (output[_D] != null) {
        contents[_D] = __expectString(output[_D]);
    }
    if (output[_CTr] != null) {
        contents[_CTr] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_CTr]));
    }
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    if (output[_E] != null) {
        contents[_E] = __expectString(output[_E]);
    }
    if (output[_MEV] != null) {
        contents[_MEV] = __expectString(output[_MEV]);
    }
    if (output[_FEV] != null) {
        contents[_FEV] = __expectString(output[_FEV]);
    }
    if (output[_CUL] != null) {
        contents[_CUL] = de_CacheUsageLimits(output[_CUL], context);
    }
    if (output[_KKI] != null) {
        contents[_KKI] = __expectString(output[_KKI]);
    }
    if (output.SecurityGroupIds === "") {
        contents[_SGI] = [];
    }
    else if (output[_SGI] != null && output[_SGI][_SGIe] != null) {
        contents[_SGI] = de_SecurityGroupIdsList(__getArrayIfSingleItem(output[_SGI][_SGIe]), context);
    }
    if (output[_End] != null) {
        contents[_End] = de_Endpoint(output[_End], context);
    }
    if (output[_RE] != null) {
        contents[_RE] = de_Endpoint(output[_RE], context);
    }
    if (output[_ARN] != null) {
        contents[_ARN] = __expectString(output[_ARN]);
    }
    if (output[_UGIs] != null) {
        contents[_UGIs] = __expectString(output[_UGIs]);
    }
    if (output.SubnetIds === "") {
        contents[_SI] = [];
    }
    else if (output[_SI] != null && output[_SI][_SIu] != null) {
        contents[_SI] = de_SubnetIdsList(__getArrayIfSingleItem(output[_SI][_SIu]), context);
    }
    if (output[_SRL] != null) {
        contents[_SRL] = __strictParseInt32(output[_SRL]);
    }
    if (output[_DST] != null) {
        contents[_DST] = __expectString(output[_DST]);
    }
    return contents;
};
const de_ServerlessCacheAlreadyExistsFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_ServerlessCacheConfiguration = (output, context) => {
    const contents = {};
    if (output[_SCN] != null) {
        contents[_SCN] = __expectString(output[_SCN]);
    }
    if (output[_E] != null) {
        contents[_E] = __expectString(output[_E]);
    }
    if (output[_MEV] != null) {
        contents[_MEV] = __expectString(output[_MEV]);
    }
    return contents;
};
const de_ServerlessCacheList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ServerlessCache(entry, context);
    });
};
const de_ServerlessCacheNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_ServerlessCacheQuotaForCustomerExceededFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_ServerlessCacheSnapshot = (output, context) => {
    const contents = {};
    if (output[_SCSN] != null) {
        contents[_SCSN] = __expectString(output[_SCSN]);
    }
    if (output[_ARN] != null) {
        contents[_ARN] = __expectString(output[_ARN]);
    }
    if (output[_KKI] != null) {
        contents[_KKI] = __expectString(output[_KKI]);
    }
    if (output[_STn] != null) {
        contents[_STn] = __expectString(output[_STn]);
    }
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    if (output[_CTr] != null) {
        contents[_CTr] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_CTr]));
    }
    if (output[_ETx] != null) {
        contents[_ETx] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_ETx]));
    }
    if (output[_BUFC] != null) {
        contents[_BUFC] = __expectString(output[_BUFC]);
    }
    if (output[_SCC] != null) {
        contents[_SCC] = de_ServerlessCacheConfiguration(output[_SCC], context);
    }
    return contents;
};
const de_ServerlessCacheSnapshotAlreadyExistsFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_ServerlessCacheSnapshotList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ServerlessCacheSnapshot(entry, context);
    });
};
const de_ServerlessCacheSnapshotNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_ServerlessCacheSnapshotQuotaExceededFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_ServiceLinkedRoleNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_ServiceUpdate = (output, context) => {
    const contents = {};
    if (output[_SUN] != null) {
        contents[_SUN] = __expectString(output[_SUN]);
    }
    if (output[_SURD] != null) {
        contents[_SURD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_SURD]));
    }
    if (output[_SUED] != null) {
        contents[_SUED] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_SUED]));
    }
    if (output[_SUSe] != null) {
        contents[_SUSe] = __expectString(output[_SUSe]);
    }
    if (output[_SURABD] != null) {
        contents[_SURABD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_SURABD]));
    }
    if (output[_SUS] != null) {
        contents[_SUS] = __expectString(output[_SUS]);
    }
    if (output[_SUD] != null) {
        contents[_SUD] = __expectString(output[_SUD]);
    }
    if (output[_SUT] != null) {
        contents[_SUT] = __expectString(output[_SUT]);
    }
    if (output[_E] != null) {
        contents[_E] = __expectString(output[_E]);
    }
    if (output[_EV] != null) {
        contents[_EV] = __expectString(output[_EV]);
    }
    if (output[_AUARABD] != null) {
        contents[_AUARABD] = __parseBoolean(output[_AUARABD]);
    }
    if (output[_EUT] != null) {
        contents[_EUT] = __expectString(output[_EUT]);
    }
    return contents;
};
const de_ServiceUpdateList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ServiceUpdate(entry, context);
    });
};
const de_ServiceUpdateNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_ServiceUpdatesMessage = (output, context) => {
    const contents = {};
    if (output[_Ma] != null) {
        contents[_Ma] = __expectString(output[_Ma]);
    }
    if (output.ServiceUpdates === "") {
        contents[_SU] = [];
    }
    else if (output[_SU] != null && output[_SU][_SUe] != null) {
        contents[_SU] = de_ServiceUpdateList(__getArrayIfSingleItem(output[_SU][_SUe]), context);
    }
    return contents;
};
const de_SlotMigration = (output, context) => {
    const contents = {};
    if (output[_PP] != null) {
        contents[_PP] = __strictParseFloat(output[_PP]);
    }
    return contents;
};
const de_Snapshot = (output, context) => {
    const contents = {};
    if (output[_SN] != null) {
        contents[_SN] = __expectString(output[_SN]);
    }
    if (output[_RGIe] != null) {
        contents[_RGIe] = __expectString(output[_RGIe]);
    }
    if (output[_RGD] != null) {
        contents[_RGD] = __expectString(output[_RGD]);
    }
    if (output[_CCIa] != null) {
        contents[_CCIa] = __expectString(output[_CCIa]);
    }
    if (output[_SSn] != null) {
        contents[_SSn] = __expectString(output[_SSn]);
    }
    if (output[_SS] != null) {
        contents[_SS] = __expectString(output[_SS]);
    }
    if (output[_CNT] != null) {
        contents[_CNT] = __expectString(output[_CNT]);
    }
    if (output[_E] != null) {
        contents[_E] = __expectString(output[_E]);
    }
    if (output[_EV] != null) {
        contents[_EV] = __expectString(output[_EV]);
    }
    if (output[_NCN] != null) {
        contents[_NCN] = __strictParseInt32(output[_NCN]);
    }
    if (output[_PAZr] != null) {
        contents[_PAZr] = __expectString(output[_PAZr]);
    }
    if (output[_POAr] != null) {
        contents[_POAr] = __expectString(output[_POAr]);
    }
    if (output[_CCCT] != null) {
        contents[_CCCT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_CCCT]));
    }
    if (output[_PMW] != null) {
        contents[_PMW] = __expectString(output[_PMW]);
    }
    if (output[_TA] != null) {
        contents[_TA] = __expectString(output[_TA]);
    }
    if (output[_Po] != null) {
        contents[_Po] = __strictParseInt32(output[_Po]);
    }
    if (output[_CPGN] != null) {
        contents[_CPGN] = __expectString(output[_CPGN]);
    }
    if (output[_CSGNa] != null) {
        contents[_CSGNa] = __expectString(output[_CSGNa]);
    }
    if (output[_VI] != null) {
        contents[_VI] = __expectString(output[_VI]);
    }
    if (output[_AMVU] != null) {
        contents[_AMVU] = __parseBoolean(output[_AMVU]);
    }
    if (output[_SRL] != null) {
        contents[_SRL] = __strictParseInt32(output[_SRL]);
    }
    if (output[_SW] != null) {
        contents[_SW] = __expectString(output[_SW]);
    }
    if (output[_NNG] != null) {
        contents[_NNG] = __strictParseInt32(output[_NNG]);
    }
    if (output[_AF] != null) {
        contents[_AF] = __expectString(output[_AF]);
    }
    if (output.NodeSnapshots === "") {
        contents[_NS] = [];
    }
    else if (output[_NS] != null && output[_NS][_NSo] != null) {
        contents[_NS] = de_NodeSnapshotList(__getArrayIfSingleItem(output[_NS][_NSo]), context);
    }
    if (output[_KKI] != null) {
        contents[_KKI] = __expectString(output[_KKI]);
    }
    if (output[_ARN] != null) {
        contents[_ARN] = __expectString(output[_ARN]);
    }
    if (output[_DTat] != null) {
        contents[_DTat] = __expectString(output[_DTat]);
    }
    return contents;
};
const de_SnapshotAlreadyExistsFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_SnapshotFeatureNotSupportedFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_SnapshotList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Snapshot(entry, context);
    });
};
const de_SnapshotNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_SnapshotQuotaExceededFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_StartMigrationResponse = (output, context) => {
    const contents = {};
    if (output[_RG] != null) {
        contents[_RG] = de_ReplicationGroup(output[_RG], context);
    }
    return contents;
};
const de_Subnet = (output, context) => {
    const contents = {};
    if (output[_SIub] != null) {
        contents[_SIub] = __expectString(output[_SIub]);
    }
    if (output[_SAZ] != null) {
        contents[_SAZ] = de_AvailabilityZone(output[_SAZ], context);
    }
    if (output[_SO] != null) {
        contents[_SO] = de_SubnetOutpost(output[_SO], context);
    }
    if (output.SupportedNetworkTypes === "") {
        contents[_SNT] = [];
    }
    else if (output[_SNT] != null && output[_SNT][_m] != null) {
        contents[_SNT] = de_NetworkTypeList(__getArrayIfSingleItem(output[_SNT][_m]), context);
    }
    return contents;
};
const de_SubnetIdsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_SubnetInUse = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_SubnetList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Subnet(entry, context);
    });
};
const de_SubnetNotAllowedFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_SubnetOutpost = (output, context) => {
    const contents = {};
    if (output[_SOA] != null) {
        contents[_SOA] = __expectString(output[_SOA]);
    }
    return contents;
};
const de_Tag = (output, context) => {
    const contents = {};
    if (output[_K] != null) {
        contents[_K] = __expectString(output[_K]);
    }
    if (output[_Val] != null) {
        contents[_Val] = __expectString(output[_Val]);
    }
    return contents;
};
const de_TagList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Tag(entry, context);
    });
};
const de_TagListMessage = (output, context) => {
    const contents = {};
    if (output.TagList === "") {
        contents[_TL] = [];
    }
    else if (output[_TL] != null && output[_TL][_Ta] != null) {
        contents[_TL] = de_TagList(__getArrayIfSingleItem(output[_TL][_Ta]), context);
    }
    return contents;
};
const de_TagNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_TagQuotaPerResourceExceeded = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_TestFailoverNotAvailableFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_TestFailoverResult = (output, context) => {
    const contents = {};
    if (output[_RG] != null) {
        contents[_RG] = de_ReplicationGroup(output[_RG], context);
    }
    return contents;
};
const de_TestMigrationResponse = (output, context) => {
    const contents = {};
    if (output[_RG] != null) {
        contents[_RG] = de_ReplicationGroup(output[_RG], context);
    }
    return contents;
};
const de_UGReplicationGroupIdList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_UGServerlessCacheIdList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_UnprocessedUpdateAction = (output, context) => {
    const contents = {};
    if (output[_RGIe] != null) {
        contents[_RGIe] = __expectString(output[_RGIe]);
    }
    if (output[_CCIa] != null) {
        contents[_CCIa] = __expectString(output[_CCIa]);
    }
    if (output[_SUN] != null) {
        contents[_SUN] = __expectString(output[_SUN]);
    }
    if (output[_ETr] != null) {
        contents[_ETr] = __expectString(output[_ETr]);
    }
    if (output[_EM] != null) {
        contents[_EM] = __expectString(output[_EM]);
    }
    return contents;
};
const de_UnprocessedUpdateActionList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_UnprocessedUpdateAction(entry, context);
    });
};
const de_UpdateAction = (output, context) => {
    const contents = {};
    if (output[_RGIe] != null) {
        contents[_RGIe] = __expectString(output[_RGIe]);
    }
    if (output[_CCIa] != null) {
        contents[_CCIa] = __expectString(output[_CCIa]);
    }
    if (output[_SUN] != null) {
        contents[_SUN] = __expectString(output[_SUN]);
    }
    if (output[_SURD] != null) {
        contents[_SURD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_SURD]));
    }
    if (output[_SUSe] != null) {
        contents[_SUSe] = __expectString(output[_SUSe]);
    }
    if (output[_SUS] != null) {
        contents[_SUS] = __expectString(output[_SUS]);
    }
    if (output[_SURABD] != null) {
        contents[_SURABD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_SURABD]));
    }
    if (output[_SUT] != null) {
        contents[_SUT] = __expectString(output[_SUT]);
    }
    if (output[_UAAD] != null) {
        contents[_UAAD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_UAAD]));
    }
    if (output[_UAS] != null) {
        contents[_UAS] = __expectString(output[_UAS]);
    }
    if (output[_NU] != null) {
        contents[_NU] = __expectString(output[_NU]);
    }
    if (output[_UASMD] != null) {
        contents[_UASMD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_UASMD]));
    }
    if (output[_SMla] != null) {
        contents[_SMla] = __expectString(output[_SMla]);
    }
    if (output.NodeGroupUpdateStatus === "") {
        contents[_NGUS] = [];
    }
    else if (output[_NGUS] != null && output[_NGUS][_NGUS] != null) {
        contents[_NGUS] = de_NodeGroupUpdateStatusList(__getArrayIfSingleItem(output[_NGUS][_NGUS]), context);
    }
    if (output.CacheNodeUpdateStatus === "") {
        contents[_CNUS] = [];
    }
    else if (output[_CNUS] != null && output[_CNUS][_CNUS] != null) {
        contents[_CNUS] = de_CacheNodeUpdateStatusList(__getArrayIfSingleItem(output[_CNUS][_CNUS]), context);
    }
    if (output[_EUT] != null) {
        contents[_EUT] = __expectString(output[_EUT]);
    }
    if (output[_E] != null) {
        contents[_E] = __expectString(output[_E]);
    }
    return contents;
};
const de_UpdateActionList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_UpdateAction(entry, context);
    });
};
const de_UpdateActionResultsMessage = (output, context) => {
    const contents = {};
    if (output.ProcessedUpdateActions === "") {
        contents[_PUA] = [];
    }
    else if (output[_PUA] != null && output[_PUA][_PUAr] != null) {
        contents[_PUA] = de_ProcessedUpdateActionList(__getArrayIfSingleItem(output[_PUA][_PUAr]), context);
    }
    if (output.UnprocessedUpdateActions === "") {
        contents[_UUA] = [];
    }
    else if (output[_UUA] != null && output[_UUA][_UUAn] != null) {
        contents[_UUA] = de_UnprocessedUpdateActionList(__getArrayIfSingleItem(output[_UUA][_UUAn]), context);
    }
    return contents;
};
const de_UpdateActionsMessage = (output, context) => {
    const contents = {};
    if (output[_Ma] != null) {
        contents[_Ma] = __expectString(output[_Ma]);
    }
    if (output.UpdateActions === "") {
        contents[_UA] = [];
    }
    else if (output[_UA] != null && output[_UA][_UAp] != null) {
        contents[_UA] = de_UpdateActionList(__getArrayIfSingleItem(output[_UA][_UAp]), context);
    }
    return contents;
};
const de_User = (output, context) => {
    const contents = {};
    if (output[_UIs] != null) {
        contents[_UIs] = __expectString(output[_UIs]);
    }
    if (output[_UN] != null) {
        contents[_UN] = __expectString(output[_UN]);
    }
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    if (output[_E] != null) {
        contents[_E] = __expectString(output[_E]);
    }
    if (output[_MEVi] != null) {
        contents[_MEVi] = __expectString(output[_MEVi]);
    }
    if (output[_AS] != null) {
        contents[_AS] = __expectString(output[_AS]);
    }
    if (output.UserGroupIds === "") {
        contents[_UGI] = [];
    }
    else if (output[_UGI] != null && output[_UGI][_m] != null) {
        contents[_UGI] = de_UserGroupIdList(__getArrayIfSingleItem(output[_UGI][_m]), context);
    }
    if (output[_Au] != null) {
        contents[_Au] = de_Authentication(output[_Au], context);
    }
    if (output[_ARN] != null) {
        contents[_ARN] = __expectString(output[_ARN]);
    }
    return contents;
};
const de_UserAlreadyExistsFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_UserGroup = (output, context) => {
    const contents = {};
    if (output[_UGIs] != null) {
        contents[_UGIs] = __expectString(output[_UGIs]);
    }
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    if (output[_E] != null) {
        contents[_E] = __expectString(output[_E]);
    }
    if (output.UserIds === "") {
        contents[_UI] = [];
    }
    else if (output[_UI] != null && output[_UI][_m] != null) {
        contents[_UI] = de_UserIdList(__getArrayIfSingleItem(output[_UI][_m]), context);
    }
    if (output[_MEVi] != null) {
        contents[_MEVi] = __expectString(output[_MEVi]);
    }
    if (output[_PCe] != null) {
        contents[_PCe] = de_UserGroupPendingChanges(output[_PCe], context);
    }
    if (output.ReplicationGroups === "") {
        contents[_RGe] = [];
    }
    else if (output[_RGe] != null && output[_RGe][_m] != null) {
        contents[_RGe] = de_UGReplicationGroupIdList(__getArrayIfSingleItem(output[_RGe][_m]), context);
    }
    if (output.ServerlessCaches === "") {
        contents[_SCe] = [];
    }
    else if (output[_SCe] != null && output[_SCe][_m] != null) {
        contents[_SCe] = de_UGServerlessCacheIdList(__getArrayIfSingleItem(output[_SCe][_m]), context);
    }
    if (output[_ARN] != null) {
        contents[_ARN] = __expectString(output[_ARN]);
    }
    return contents;
};
const de_UserGroupAlreadyExistsFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_UserGroupIdList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_UserGroupList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_UserGroup(entry, context);
    });
};
const de_UserGroupNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_UserGroupPendingChanges = (output, context) => {
    const contents = {};
    if (output.UserIdsToRemove === "") {
        contents[_UITR] = [];
    }
    else if (output[_UITR] != null && output[_UITR][_m] != null) {
        contents[_UITR] = de_UserIdList(__getArrayIfSingleItem(output[_UITR][_m]), context);
    }
    if (output.UserIdsToAdd === "") {
        contents[_UITA] = [];
    }
    else if (output[_UITA] != null && output[_UITA][_m] != null) {
        contents[_UITA] = de_UserIdList(__getArrayIfSingleItem(output[_UITA][_m]), context);
    }
    return contents;
};
const de_UserGroupQuotaExceededFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_UserGroupsUpdateStatus = (output, context) => {
    const contents = {};
    if (output.UserGroupIdsToAdd === "") {
        contents[_UGITA] = [];
    }
    else if (output[_UGITA] != null && output[_UGITA][_m] != null) {
        contents[_UGITA] = de_UserGroupIdList(__getArrayIfSingleItem(output[_UGITA][_m]), context);
    }
    if (output.UserGroupIdsToRemove === "") {
        contents[_UGITR] = [];
    }
    else if (output[_UGITR] != null && output[_UGITR][_m] != null) {
        contents[_UGITR] = de_UserGroupIdList(__getArrayIfSingleItem(output[_UGITR][_m]), context);
    }
    return contents;
};
const de_UserIdList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_UserList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_User(entry, context);
    });
};
const de_UserNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_UserQuotaExceededFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const throwDefaultError = withBaseException(__BaseException);
const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const contents = {
        protocol,
        hostname,
        port,
        method: "POST",
        path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
        headers,
    };
    if (resolvedHostname !== undefined) {
        contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
        contents.body = body;
    }
    return new __HttpRequest(contents);
};
const SHARED_HEADERS = {
    "content-type": "application/x-www-form-urlencoded",
};
const _ = "2015-02-02";
const _A = "Action";
const _AAS = "AppendAccessString";
const _ACSGI = "AuthorizeCacheSecurityGroupIngress";
const _AF = "AutomaticFailover";
const _AFE = "AutomaticFailoverEnabled";
const _AFS = "AutomaticFailoverStatus";
const _AI = "ApplyImmediately";
const _AM = "AuthenticationMode";
const _AMVU = "AutoMinorVersionUpgrade";
const _AREE = "AtRestEncryptionEnabled";
const _ARN = "ARN";
const _AS = "AccessString";
const _AT = "AuthToken";
const _ATE = "AuthTokenEnabled";
const _ATLMD = "AuthTokenLastModifiedDate";
const _ATS = "AuthTokenStatus";
const _ATTR = "AddTagsToResource";
const _ATUS = "AuthTokenUpdateStrategy";
const _AUARABD = "AutoUpdateAfterRecommendedApplyByDate";
const _AV = "AllowedValues";
const _AZ = "AvailabilityZone";
const _AZM = "AZMode";
const _Ad = "Address";
const _Au = "Authentication";
const _BAUA = "BatchApplyUpdateAction";
const _BSUA = "BatchStopUpdateAction";
const _BUFC = "BytesUsedForCache";
const _CAZ = "CustomerAvailabilityZone";
const _CC = "CacheClusters";
const _CCC = "CreateCacheCluster";
const _CCCT = "CacheClusterCreateTime";
const _CCI = "CacheClusterIds";
const _CCIa = "CacheClusterId";
const _CCPG = "CreateCacheParameterGroup";
const _CCS = "CacheClusterStatus";
const _CCSG = "CreateCacheSecurityGroup";
const _CCSGr = "CreateCacheSubnetGroup";
const _CCa = "CacheCluster";
const _CDLP = "ClientDownloadLandingPage";
const _CE = "ConfigurationEndpoint";
const _CED = "CacheEngineDescription";
const _CEV = "CacheEngineVersions";
const _CEVD = "CacheEngineVersionDescription";
const _CEVa = "CacheEngineVersion";
const _CEl = "ClusterEnabled";
const _CGRG = "CreateGlobalReplicationGroup";
const _CI = "ClusterId";
const _CM = "CompleteMigration";
const _CMl = "ClusterMode";
const _CN = "CacheNodes";
const _CNC = "CacheNodeCount";
const _CNCT = "CacheNodeCreateTime";
const _CNEL = "CustomerNodeEndpointList";
const _CNI = "CacheNodeId";
const _CNITR = "CacheNodeIdsToRemove";
const _CNITRa = "CacheNodeIdsToReboot";
const _CNS = "CacheNodeStatus";
const _CNT = "CacheNodeType";
const _CNTSP = "CacheNodeTypeSpecificParameters";
const _CNTSPa = "CacheNodeTypeSpecificParameter";
const _CNTSV = "CacheNodeTypeSpecificValues";
const _CNTSVa = "CacheNodeTypeSpecificValue";
const _CNUS = "CacheNodeUpdateStatus";
const _CNa = "CacheNode";
const _COA = "CustomerOutpostArn";
const _CPG = "CacheParameterGroup";
const _CPGF = "CacheParameterGroupFamily";
const _CPGN = "CacheParameterGroupName";
const _CPGa = "CacheParameterGroups";
const _CR = "CurrentRole";
const _CRG = "CreateReplicationGroup";
const _CS = "CopySnapshot";
const _CSC = "CreateServerlessCache";
const _CSCS = "CopyServerlessCacheSnapshot";
const _CSCSr = "CreateServerlessCacheSnapshot";
const _CSG = "CacheSecurityGroup";
const _CSGD = "CacheSubnetGroupDescription";
const _CSGN = "CacheSecurityGroupName";
const _CSGNa = "CacheSubnetGroupName";
const _CSGNac = "CacheSecurityGroupNames";
const _CSGa = "CacheSecurityGroups";
const _CSGac = "CacheSubnetGroups";
const _CSGach = "CacheSubnetGroup";
const _CSa = "CacheSize";
const _CSr = "CreateSnapshot";
const _CT = "ChangeType";
const _CTr = "CreateTime";
const _CU = "CreateUser";
const _CUG = "CreateUserGroup";
const _CUL = "CacheUsageLimits";
const _CWLD = "CloudWatchLogsDetails";
const _D = "Description";
const _DCC = "DeleteCacheCluster";
const _DCCe = "DescribeCacheClusters";
const _DCEV = "DescribeCacheEngineVersions";
const _DCP = "DescribeCacheParameters";
const _DCPG = "DeleteCacheParameterGroup";
const _DCPGe = "DescribeCacheParameterGroups";
const _DCSG = "DeleteCacheSecurityGroup";
const _DCSGe = "DeleteCacheSubnetGroup";
const _DCSGes = "DescribeCacheSecurityGroups";
const _DCSGesc = "DescribeCacheSubnetGroups";
const _DD = "DestinationDetails";
const _DE = "DescribeEvents";
const _DEDP = "DescribeEngineDefaultParameters";
const _DGRG = "DeleteGlobalReplicationGroup";
const _DGRGe = "DescribeGlobalReplicationGroups";
const _DGRGi = "DisassociateGlobalReplicationGroup";
const _DNGIGRG = "DecreaseNodeGroupsInGlobalReplicationGroup";
const _DO = "DefaultOnly";
const _DRC = "DecreaseReplicaCount";
const _DRCN = "DescribeReservedCacheNodes";
const _DRCNO = "DescribeReservedCacheNodesOfferings";
const _DRG = "DeleteReplicationGroup";
const _DRGe = "DescribeReplicationGroups";
const _DS = "DeleteSnapshot";
const _DSC = "DeleteServerlessCache";
const _DSCS = "DeleteServerlessCacheSnapshot";
const _DSCSe = "DescribeServerlessCacheSnapshots";
const _DSCe = "DescribeServerlessCaches";
const _DST = "DailySnapshotTime";
const _DSU = "DescribeServiceUpdates";
const _DSa = "DataStorage";
const _DSe = "DescribeSnapshots";
const _DSel = "DeliveryStream";
const _DT = "DestinationType";
const _DTE = "DataTieringEnabled";
const _DTa = "DataType";
const _DTat = "DataTiering";
const _DU = "DeleteUser";
const _DUA = "DescribeUpdateActions";
const _DUG = "DeleteUserGroup";
const _DUGe = "DescribeUserGroups";
const _DUe = "DescribeUsers";
const _Da = "Date";
const _Du = "Duration";
const _E = "Engine";
const _ECPUPS = "ECPUPerSecond";
const _ECSG = "EC2SecurityGroups";
const _ECSGN = "EC2SecurityGroupName";
const _ECSGOI = "EC2SecurityGroupOwnerId";
const _ECSGe = "EC2SecurityGroup";
const _ED = "EngineDefaults";
const _EM = "ErrorMessage";
const _ESCS = "ExportServerlessCacheSnapshot";
const _ET = "EndTime";
const _ETr = "ErrorType";
const _ETx = "ExpiryTime";
const _EUT = "EstimatedUpdateTime";
const _EV = "EngineVersion";
const _En = "Enabled";
const _End = "Endpoint";
const _Ev = "Events";
const _Eve = "Event";
const _F = "Force";
const _FEV = "FullEngineVersion";
const _FGRG = "FailoverGlobalReplicationGroup";
const _FP = "FixedPrice";
const _FSI = "FinalSnapshotIdentifier";
const _FSN = "FinalSnapshotName";
const _Fi = "Filters";
const _GNG = "GlobalNodeGroups";
const _GNGI = "GlobalNodeGroupId";
const _GNGTR = "GlobalNodeGroupsToRemove";
const _GNGTRl = "GlobalNodeGroupsToRetain";
const _GNGl = "GlobalNodeGroup";
const _GRG = "GlobalReplicationGroup";
const _GRGD = "GlobalReplicationGroupDescription";
const _GRGI = "GlobalReplicationGroupId";
const _GRGIS = "GlobalReplicationGroupIdSuffix";
const _GRGIl = "GlobalReplicationGroupInfo";
const _GRGM = "GlobalReplicationGroupMember";
const _GRGMR = "GlobalReplicationGroupMemberRole";
const _GRGl = "GlobalReplicationGroups";
const _ID = "IpDiscovery";
const _IG = "IsGlobal";
const _IM = "IsModifiable";
const _INGIGRG = "IncreaseNodeGroupsInGlobalReplicationGroup";
const _IRC = "IncreaseReplicaCount";
const _K = "Key";
const _KFD = "KinesisFirehoseDetails";
const _KKI = "KmsKeyId";
const _LANTM = "ListAllowedNodeTypeModifications";
const _LDC = "LogDeliveryConfigurations";
const _LDCo = "LogDeliveryConfiguration";
const _LF = "LogFormat";
const _LG = "LogGroup";
const _LT = "LogType";
const _LTFR = "ListTagsForResource";
const _M = "Maximum";
const _MAZ = "MultiAZ";
const _MAZE = "MultiAZEnabled";
const _MC = "MemberClusters";
const _MCC = "ModifyCacheCluster";
const _MCOA = "MemberClustersOutpostArns";
const _MCPG = "ModifyCacheParameterGroup";
const _MCSG = "ModifyCacheSubnetGroup";
const _MEV = "MajorEngineVersion";
const _MEVi = "MinimumEngineVersion";
const _MGRG = "ModifyGlobalReplicationGroup";
const _MR = "MaxRecords";
const _MRG = "ModifyReplicationGroup";
const _MRGSC = "ModifyReplicationGroupShardConfiguration";
const _MRa = "MaxResults";
const _MSC = "ModifyServerlessCache";
const _MU = "ModifyUser";
const _MUG = "ModifyUserGroup";
const _Ma = "Marker";
const _Me = "Message";
const _Mem = "Members";
const _Mi = "Minimum";
const _N = "Name";
const _NAZ = "NewAvailabilityZones";
const _NC = "NotificationConfiguration";
const _NCC = "NumCacheClusters";
const _NCN = "NumCacheNodes";
const _NDD = "NodeDeletionDate";
const _NG = "NodeGroups";
const _NGC = "NodeGroupConfiguration";
const _NGCo = "NodeGroupCount";
const _NGI = "NodeGroupId";
const _NGM = "NodeGroupMembers";
const _NGMUS = "NodeGroupMemberUpdateStatus";
const _NGMo = "NodeGroupMember";
const _NGTR = "NodeGroupsToRemove";
const _NGTRo = "NodeGroupsToRetain";
const _NGUS = "NodeGroupUpdateStatus";
const _NGo = "NodeGroup";
const _NNG = "NumNodeGroups";
const _NPR = "NoPasswordRequired";
const _NRC = "NewReplicaCount";
const _NS = "NodeSnapshots";
const _NSo = "NodeSnapshot";
const _NT = "NetworkType";
const _NTA = "NotificationTopicArn";
const _NTS = "NotificationTopicStatus";
const _NTe = "NextToken";
const _NU = "NodesUpdated";
const _NUED = "NodeUpdateEndDate";
const _NUIB = "NodeUpdateInitiatedBy";
const _NUID = "NodeUpdateInitiatedDate";
const _NUS = "NodeUpdateStatus";
const _NUSD = "NodeUpdateStartDate";
const _NUSMD = "NodeUpdateStatusModifiedDate";
const _OA = "OutpostArn";
const _OI = "OwnerId";
const _OM = "OutpostMode";
const _OT = "OfferingType";
const _P = "Passwords";
const _PAS = "ParameterApplyStatus";
const _PAZ = "PreferredAvailabilityZones";
const _PAZr = "PreferredAvailabilityZone";
const _PAZri = "PrimaryAvailabilityZone";
const _PC = "PasswordCount";
const _PCCAZ = "PreferredCacheClusterAZs";
const _PCI = "PrimaryClusterId";
const _PCe = "PendingChanges";
const _PD = "ProductDescription";
const _PE = "PrimaryEndpoint";
const _PGS = "ParameterGroupStatus";
const _PMV = "PendingModifiedValues";
const _PMW = "PreferredMaintenanceWindow";
const _PN = "ParameterName";
const _PNV = "ParameterNameValues";
const _POA = "PreferredOutpostArns";
const _POAr = "PreferredOutpostArn";
const _POAri = "PrimaryOutpostArn";
const _PP = "ProgressPercentage";
const _PR = "PrimaryRegion";
const _PRCNO = "PurchaseReservedCacheNodesOffering";
const _PRGI = "PrimaryReplicationGroupId";
const _PUA = "ProcessedUpdateActions";
const _PUAr = "ProcessedUpdateAction";
const _PV = "ParameterValue";
const _Pa = "Parameters";
const _Par = "Parameter";
const _Po = "Port";
const _R = "Role";
const _RAP = "ResetAllParameters";
const _RARN = "ReservationARN";
const _RAZ = "ReplicaAvailabilityZones";
const _RC = "ReplicaConfiguration";
const _RCA = "RecurringChargeAmount";
const _RCC = "RebootCacheCluster";
const _RCF = "RecurringChargeFrequency";
const _RCN = "ReservedCacheNode";
const _RCNI = "ReservedCacheNodeId";
const _RCNO = "ReservedCacheNodesOfferings";
const _RCNOI = "ReservedCacheNodesOfferingId";
const _RCNOe = "ReservedCacheNodesOffering";
const _RCNe = "ReservedCacheNodes";
const _RCPG = "ResetCacheParameterGroup";
const _RCSGI = "RevokeCacheSecurityGroupIngress";
const _RCe = "RegionalConfigurations";
const _RCec = "RecurringCharges";
const _RCecu = "RecurringCharge";
const _RCep = "ReplicaCount";
const _RCes = "ReshardingConfiguration";
const _RE = "ReaderEndpoint";
const _REe = "ReadEndpoint";
const _RG = "ReplicationGroup";
const _RGCT = "ReplicationGroupCreateTime";
const _RGD = "ReplicationGroupDescription";
const _RGI = "ReplicationGroupIds";
const _RGIe = "ReplicationGroupId";
const _RGLDE = "ReplicationGroupLogDeliveryEnabled";
const _RGOA = "ReplicationGroupOutpostArn";
const _RGR = "ReplicationGroupRegion";
const _RGe = "ReplicationGroups";
const _RN = "ResourceName";
const _ROA = "ReplicaOutpostArns";
const _RPC = "RetainPrimaryCluster";
const _RPNG = "ReplicasPerNodeGroup";
const _RPRG = "RetainPrimaryReplicationGroup";
const _RSIGRG = "RebalanceSlotsInGlobalReplicationGroup";
const _RTFR = "RemoveTagsFromResource";
const _RTR = "ReplicasToRemove";
const _RUG = "RemoveUserGroups";
const _RUGe = "RemoveUserGroup";
const _Re = "Resharding";
const _S = "Source";
const _SA = "SnapshotArns";
const _SATR = "SnapshotArnsToRestore";
const _SAZ = "SubnetAvailabilityZone";
const _SBN = "S3BucketName";
const _SC = "ServerlessCache";
const _SCC = "ServerlessCacheConfiguration";
const _SCCNIRG = "ShowCacheClustersNotInReplicationGroups";
const _SCI = "SnapshottingClusterId";
const _SCN = "ServerlessCacheName";
const _SCNI = "ShowCacheNodeInfo";
const _SCNIo = "SourceCacheNodeId";
const _SCS = "ServerlessCacheSnapshot";
const _SCSN = "ServerlessCacheSnapshotName";
const _SCSe = "ServerlessCacheSnapshots";
const _SCT = "SnapshotCreateTime";
const _SCe = "ServerlessCaches";
const _SDM = "ScaleDownModifications";
const _SG = "SecurityGroups";
const _SGI = "SecurityGroupIds";
const _SGIe = "SecurityGroupId";
const _SI = "SubnetIds";
const _SIo = "SourceIdentifier";
const _SIu = "SubnetId";
const _SIub = "SubnetIdentifier";
const _SM = "StartMigration";
const _SMI = "ShowMemberInfo";
const _SMl = "SlotMigration";
const _SMla = "SlaMet";
const _SN = "SnapshotName";
const _SNGC = "ShowNodeGroupConfig";
const _SNLUS = "ShowNodeLevelUpdateStatus";
const _SNT = "SupportedNetworkTypes";
const _SO = "SubnetOutpost";
const _SOA = "SubnetOutpostArn";
const _SRL = "SnapshotRetentionLimit";
const _SS = "SnapshotSource";
const _SSCSN = "SourceServerlessCacheSnapshotName";
const _SSN = "SourceSnapshotName";
const _SSn = "SnapshotStatus";
const _ST = "SourceType";
const _STn = "SnapshotType";
const _STt = "StartTime";
const _SU = "ServiceUpdates";
const _SUD = "ServiceUpdateDescription";
const _SUED = "ServiceUpdateEndDate";
const _SUM = "ScaleUpModifications";
const _SUN = "ServiceUpdateName";
const _SURABD = "ServiceUpdateRecommendedApplyByDate";
const _SURD = "ServiceUpdateReleaseDate";
const _SUS = "ServiceUpdateStatus";
const _SUSe = "ServiceUpdateSeverity";
const _SUT = "ServiceUpdateType";
const _SUTR = "ServiceUpdateTimeRange";
const _SUe = "ServiceUpdate";
const _SW = "SnapshotWindow";
const _Sl = "Slots";
const _Sn = "Snapshot";
const _Sna = "Snapshots";
const _St = "Status";
const _Sta = "State";
const _Su = "Subnets";
const _Sub = "Subnet";
const _T = "Tags";
const _TA = "TopicArn";
const _TB = "TargetBucket";
const _TEE = "TransitEncryptionEnabled";
const _TEM = "TransitEncryptionMode";
const _TF = "TestFailover";
const _TK = "TagKeys";
const _TL = "TagList";
const _TM = "TestMigration";
const _TS = "TopicStatus";
const _TSCSN = "TargetServerlessCacheSnapshotName";
const _TSN = "TargetSnapshotName";
const _Ta = "Tag";
const _Ty = "Type";
const _U = "Unit";
const _UA = "UpdateActions";
const _UAAD = "UpdateActionAvailableDate";
const _UAS = "UpdateActionStatus";
const _UASMD = "UpdateActionStatusModifiedDate";
const _UAp = "UpdateAction";
const _UG = "UserGroups";
const _UGI = "UserGroupIds";
const _UGITA = "UserGroupIdsToAdd";
const _UGITR = "UserGroupIdsToRemove";
const _UGIs = "UserGroupId";
const _UI = "UserIds";
const _UITA = "UserIdsToAdd";
const _UITR = "UserIdsToRemove";
const _UIs = "UserId";
const _UN = "UserName";
const _UP = "UsagePrice";
const _UUA = "UnprocessedUpdateActions";
const _UUAn = "UnprocessedUpdateAction";
const _Us = "Users";
const _V = "Version";
const _VI = "VpcId";
const _Va = "Values";
const _Val = "Value";
const _m = "member";
const _me = "message";
const buildFormUrlencodedString = (formEntries) => Object.entries(formEntries)
    .map(([key, value]) => __extendedEncodeURIComponent(key) + "=" + __extendedEncodeURIComponent(value))
    .join("&");
const loadQueryErrorCode = (output, data) => {
    if (data.Error?.Code !== undefined) {
        return data.Error.Code;
    }
    if (output.statusCode == 404) {
        return "NotFound";
    }
};
